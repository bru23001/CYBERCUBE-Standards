# CYBERCUBE Webhooks & External Integrations Standard (v1)

## Glossary

This glossary defines key terms used throughout the CYBERCUBE Webhooks & External
Integrations Standard.

All definitions are normative unless stated otherwise.

### A

#### Acknowledgment

A successful HTTP response (2xx) from the receiver indicating the webhook was received.

Requirements:
- Status code: 200-299
- Response time: â‰¤ 30 seconds
- Body: optional (ignored)

Failure to acknowledge triggers retry.

#### At-Least-Once Delivery

A delivery guarantee where events may be delivered multiple times but never lost.

CYBERCUBE guarantees at-least-once delivery:
- Events persist until acknowledged
- Retries on failure
- Receivers MUST handle duplicates

See also: Idempotency

### B

#### Backoff

The increasing delay between retry attempts.

CYBERCUBE uses exponential backoff:
```
Attempt 1: immediate
Attempt 2: 1 minute
Attempt 3: 5 minutes
Attempt 4: 30 minutes
Attempt 5: 2 hours
Attempt 6: 8 hours
Attempt 7: 24 hours
```

### C

#### Callback URL

The HTTPS endpoint where webhooks are delivered.

Requirements:
- HTTPS required (TLS 1.2+)
- Reachable from CYBERCUBE infrastructure (public internet or approved network peering)
- Responds within timeout
- Returns 2xx on success

### D

#### Dead Letter Queue (DLQ)

Storage for events that failed all delivery attempts.

Purpose:
- Preserve failed events
- Enable manual investigation
- Support replay after fix

Retention: 30 days

#### Delivery

The process of sending a webhook event to the receiver's endpoint.

Phases:
1. Event creation
2. Payload construction
3. Signature generation
4. HTTP POST to callback URL
5. Response evaluation
6. Retry or completion

#### Delivery Attempt

A single HTTP request to the callback URL.

Tracked data:
- Attempt number
- Timestamp
- Response status
- Response time
- Error message (if failed)

### E

#### Endpoint

A registered callback URL for webhook delivery.

Also known as: Webhook URL, Callback URL, Destination

#### Event

A notification of something that happened in the system.

Structure:
```json
{
  "id": "evt_...",
  "type": "project.created",
  "created_at": "2026-01-17T12:00:00Z",
  "data": {...}
}
```

Events are:
- Immutable (never modified)
- Ordered by creation time
- Unique (by ID)
- Typed (by event type)

#### Event ID

A unique identifier for each event.

Format: `evt_{random26}` â€” 30 characters total (4-char prefix + 26 random alphanumeric)

Properties:
- Globally unique
- Used for idempotency
- Used for deduplication
- Included in all deliveries

#### Event Schema

The structure definition for event payloads.

CYBERCUBE uses JSON Schema for validation.

#### Event Type

A string identifying what happened.

Format: `{resource}.{action}` or `{resource}.{action}.{detail}`

Examples:
- `project.created`
- `invoice.payment.succeeded`
- `user.subscription.upgraded`

### F

#### Fan-Out

Delivering one event to multiple endpoints.

Rules:
- Same event ID for all deliveries
- Independent retry per endpoint
- Parallel delivery (best effort)

#### Filter

A rule limiting which events are delivered to an endpoint.

Types:
- Event type filter
- Resource filter
- Attribute filter

### H

#### HMAC (Hash-based Message Authentication Code)

The cryptographic algorithm used for webhook signatures.

CYBERCUBE uses HMAC-SHA256.

### I

#### Idempotency

The property ensuring duplicate deliveries produce the same result.

Receivers MUST:
- Track received event IDs
- Deduplicate before processing
- Return 200 for seen events

#### Idempotency Key

The event ID serves as the idempotency key.

Receivers use this to detect and ignore duplicates.

#### Integration

A configured connection between CYBERCUBE and an external system.

Types:
- Webhook (outbound events)
- OAuth app (inbound API)
- Native integration (pre-built)

### M

#### Message

The complete HTTP request sent to the webhook endpoint.

Components:
- Method: POST
- Headers: signature, timestamp, etc.
- Body: JSON event payload

### O

#### Outbound Webhook

A webhook sent FROM CYBERCUBE TO an external system.

This standard primarily covers outbound webhooks.

### P

#### Payload

The JSON body of the webhook HTTP request.

Contains:
- Event metadata (id, type, created_at)
- Event data (resource snapshot)
- Context (account, user, etc.)

### R

#### Replay

Re-delivering events that were previously sent.

Use cases:
- Endpoint was down
- Processing bug fixed
- New endpoint setup

#### Retry

An additional delivery attempt after failure.

CYBERCUBE retries:
- On 5xx response or 429 (Too Many Requests)
- On timeout (>30s)
- On connection error
- Up to 7 attempts over ~34.5 hours
- Does NOT retry on other 4xx responses

### S

#### Secret

A cryptographic key used for webhook signature verification.

Properties:
- 32 bytes (256 bits)
- Base64 encoded for storage
- Unique per endpoint
- Rotatable

Format: `whsec_{base64url}`

#### Signature

A cryptographic proof that the webhook came from CYBERCUBE.

Header: `X-Webhook-Signature`

Algorithm: HMAC-SHA256

#### Signing Secret

Synonym for Secret.

The shared key between CYBERCUBE and the receiver for signature verification.

#### Subscription

A registered webhook endpoint configuration.

Contains:
- Endpoint URL
- Event types
- Secret
- Status (active/paused/disabled)

### T

#### Timeout

The maximum time allowed for endpoint response.

CYBERCUBE timeout: 30 seconds

Exceeding timeout = delivery failure = retry

#### Timestamp

The Unix timestamp when the webhook was sent.

Header: `X-Webhook-Timestamp`

Used for:
- Replay attack prevention
- Signature verification
- Audit logging

#### Tolerance

The maximum age of a valid timestamp.

CYBERCUBE tolerance: 5 minutes (300 seconds)

Timestamps older than tolerance MUST be rejected.

### W

#### Webhook

An HTTP callback triggered by an event.

Components:
- Event (what happened)
- Endpoint (where to send)
- Payload (what to send)
- Signature (proof of origin)

---

# CYBERCUBE Webhooks & External Integrations Standard (v1)

**Status:** Active
**Effective:** 2026-01-17
**Applies to:** All CYBERCUBE webhook and external integration implementations

## 0. Purpose & Design Principles

This standard defines how CYBERCUBE delivers event notifications to external systems via
webhooks and integrates with third-party services. It establishes security, reliability,
and consistency requirements.

Industry alignment:
- Stripe Webhook Specification
- GitHub Webhooks
- Twilio Webhook Security
- AWS EventBridge patterns
- CloudEvents Specification

Design principles:

1. **Security First** â€” Signed, verified, encrypted in transit
2. **Reliability** â€” At-least-once delivery with retries
3. **Idempotency** â€” Receivers can safely process duplicates
4. **Observability** â€” Full delivery tracking and debugging
5. **Simplicity** â€” Easy to implement and integrate
6. **Standards-Based** â€” Follow industry best practices

This document does NOT define:
- Internal event bus architecture
- Authentication for inbound APIs â€” see Authentication Standard
- API design patterns â€” see API Design Standard
- OAuth app integrations â€” forthcoming in a future standard
- Native (pre-built) integrations â€” forthcoming in a future standard

## 1. Webhook Architecture

CYBERCUBE implements a reliable webhook delivery system with guaranteed at-least-once
delivery semantics.

### 1.1 System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CYBERCUBE PLATFORM                           â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Service â”‚â”€â”€â”€â–¶â”‚ Event Bus   â”‚â”€â”€â”€â–¶â”‚ Webhook Dispatcher  â”‚     â”‚
â”‚  â”‚ (API)   â”‚    â”‚ (Queue)     â”‚    â”‚                     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚     â”‚
â”‚                                    â”‚ â”‚ Signing Service â”‚ â”‚     â”‚
â”‚                                    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚     â”‚
â”‚                                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚     â”‚
â”‚                                    â”‚ â”‚ Delivery Engine â”‚ â”‚     â”‚
â”‚                                    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚     â”‚
â”‚                                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚     â”‚
â”‚                                    â”‚ â”‚ Retry Manager   â”‚ â”‚     â”‚
â”‚                                    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚     â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚
                                                â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚    External Endpoint (HTTPS)    â”‚
                              â”‚    https://example.com/webhook  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Delivery Guarantees

| Guarantee | Description |
|-----------|-------------|
| At-least-once | Events delivered at least once (may duplicate) |
| Ordered (best effort) | Events sent in creation order (no strict guarantee) |
| Durable | Events persisted until acknowledged |
| Retry on failure | Failed deliveries retried with backoff |

### 1.3 Event Flow

```
1. Action occurs in CYBERCUBE
        â†“
2. Event created and persisted
        â†“
3. Event added to delivery queue
        â†“
4. For each subscribed endpoint:
    a. Build payload
    b. Generate signature
    c. POST to endpoint
    d. Evaluate response
        â†“
5. Success (2xx): Mark delivered
   Failure: Schedule retry
        â†“
6. After max retries: Move to DLQ
```

## 2. Event Schema

Events follow a consistent schema for all webhook deliveries.

### 2.1 Event Structure

```typescript
interface WebhookEvent {
  // Event identification
  id: string;                    // Unique event ID: evt_...
  type: string;                  // Event type: resource.action
  api_version: string;           // API version: 2026-01-17
  
  // Timestamps
  created_at: string;            // Event creation time (ISO 8601)
  
  // Event data
  data: {
    object: ResourceObject;      // The affected resource
    previous_attributes?: object;// Changed fields (for updates)
  };
  
  // Context
  account_id: string;            // Tenant CC-PID: ACC-...
  livemode: boolean;             // true = production, false = test
  
  // Delivery metadata (in headers, not body)
  // X-Webhook-ID: Delivery attempt ID
  // X-Webhook-Timestamp: Delivery timestamp
}
```

### 2.2 Resource Object

```typescript
interface ResourceObject {
  id: string;                    // Resource CC-PID
  object: string;                // Resource type (singular)
  // ... resource-specific fields
  created_at: string;
  updated_at: string;
}
```

### 2.3 Event Example

```json
{
  "id": "evt_1MqLi2J3K4L5M6N7O8P9Q0R1",
  "type": "project.created",
  "api_version": "2026-01-17",
  "created_at": "2026-01-17T12:00:00Z",
  "data": {
    "object": {
      "id": "PRJ-X2M8KD-7",
      "object": "project",
      "name": "Customer Portal",
      "description": "New customer portal project",
      "status": "active",
      "owner_id": "USR-4Q7T9P-K",
      "created_at": "2026-01-17T12:00:00Z",
      "updated_at": "2026-01-17T12:00:00Z"
    }
  },
  "account_id": "ACC-9F4K7Q-M",
  "livemode": true
}
```

### 2.4 Update Event with Previous Attributes

```json
{
  "id": "evt_2NrMj3K4L5M6N7O8P9Q0R1S2",
  "type": "project.updated",
  "api_version": "2026-01-17",
  "created_at": "2026-01-17T14:30:00Z",
  "data": {
    "object": {
      "id": "PRJ-X2M8KD-7",
      "object": "project",
      "name": "Customer Portal v2",
      "status": "active",
      "updated_at": "2026-01-17T14:30:00Z"
    },
    "previous_attributes": {
      "name": "Customer Portal"
    }
  },
  "account_id": "ACC-9F4K7Q-M",
  "livemode": true
}
```

### 2.5 Event Types

Format: `{resource}.{action}` or `{resource}.{sub_resource}.{action}`

**Project events:**
| Event Type | Description |
|------------|-------------|
| `project.created` | New project created |
| `project.updated` | Project details changed |
| `project.deleted` | Project deleted |
| `project.archived` | Project archived |
| `project.restored` | Project restored from archive |

**Task events:**
| Event Type | Description |
|------------|-------------|
| `task.created` | New task created |
| `task.updated` | Task details changed |
| `task.deleted` | Task deleted |
| `task.assigned` | Task assigned to user |
| `task.completed` | Task marked complete |
| `task.reopened` | Completed task reopened |

**Invoice events:**
| Event Type | Description |
|------------|-------------|
| `invoice.created` | New invoice created |
| `invoice.updated` | Invoice details changed |
| `invoice.sent` | Invoice sent to customer |
| `invoice.paid` | Invoice payment received |
| `invoice.voided` | Invoice voided |
| `invoice.payment.failed` | Payment attempt failed |
| `invoice.payment.succeeded` | Payment succeeded |

**User events:**
| Event Type | Description |
|------------|-------------|
| `user.created` | New user registered |
| `user.updated` | User details changed |
| `user.deleted` | User account deleted |
| `user.invited` | User invited to account |
| `user.activated` | User account activated |
| `user.suspended` | User account suspended |

**Milestone events:**
| Event Type | Description |
|------------|-------------|
| `milestone.created` | Milestone created |
| `milestone.updated` | Milestone updated |
| `milestone.completed` | Milestone completed |
| `milestone.missed` | Milestone deadline passed |

**Deliverable events:**
| Event Type | Description |
|------------|-------------|
| `deliverable.created` | Deliverable created |
| `deliverable.updated` | Deliverable updated |
| `deliverable.submitted` | Deliverable submitted for review |
| `deliverable.approved` | Deliverable approved |
| `deliverable.rejected` | Deliverable rejected |

### 2.6 Event ID Format

Format: `evt_{random26}`

Generation:
- Prefix: `evt_`
- Random: 26 characters from `[A-Za-z0-9]`
- Total: 30 characters

Properties:
- Globally unique
- Time-ordered (embedded timestamp optional)
- URL-safe

## 3. Webhook Signing

All webhooks are cryptographically signed to prove authenticity.

### 3.1 Signature Algorithm

Algorithm: HMAC-SHA256

Signature format: `sha256={hex_digest}`

### 3.2 Signature Construction

```
signature = HMAC-SHA256(
  key: webhook_secret,
  message: timestamp + "." + payload
)
```

Where:
- `webhook_secret`: The endpoint's signing secret
- `timestamp`: Unix timestamp (seconds)
- `payload`: Raw JSON body (exact bytes)

### 3.3 Signature Headers

| Header | Description | Example |
|--------|-------------|---------|
| `X-Webhook-Signature` | HMAC-SHA256 signature | `sha256=abc123...` |
| `X-Webhook-Timestamp` | Unix timestamp (seconds) | `1737100000` |
| `X-Webhook-ID` | Delivery attempt ID | `wh_1A2B3C4D5E` |

### 3.4 Signature Verification (Receiver)

```typescript
// Node.js/TypeScript reference implementation
import crypto from 'crypto';

interface VerificationResult {
  valid: boolean;
  error?: string;
}

function verifyWebhookSignature(
  payload: string,           // Raw request body
  signature: string,         // X-Webhook-Signature header
  timestamp: string,         // X-Webhook-Timestamp header
  secret: string,            // Webhook signing secret
  tolerance: number = 300    // Max age in seconds (5 min default)
): VerificationResult {
  
  // 1. Extract signature hash
  if (!signature.startsWith('sha256=')) {
    return { valid: false, error: 'Invalid signature format' };
  }
  const receivedHash = signature.slice(7);
  
  // 2. Validate timestamp
  const timestampNum = parseInt(timestamp, 10);
  if (isNaN(timestampNum)) {
    return { valid: false, error: 'Invalid timestamp' };
  }
  
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - timestampNum) > tolerance) {
    return { valid: false, error: 'Timestamp outside tolerance window' };
  }
  
  // 3. Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const expectedHash = crypto
    .createHmac('sha256', secret)
    .update(signedPayload, 'utf8')
    .digest('hex');
  
  // 4. Timing-safe comparison
  try {
    const valid = crypto.timingSafeEqual(
      Buffer.from(receivedHash, 'hex'),
      Buffer.from(expectedHash, 'hex')
    );
    return { valid };
  } catch {
    return { valid: false, error: 'Signature mismatch' };
  }
}

// Usage example
app.post('/webhooks/cybercube', (req, res) => {
  const result = verifyWebhookSignature(
    req.rawBody,
    req.headers['x-webhook-signature'],
    req.headers['x-webhook-timestamp'],
    process.env.WEBHOOK_SECRET
  );
  
  if (!result.valid) {
    console.error('Webhook verification failed:', result.error);
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process webhook...
  res.status(200).json({ received: true });
});
```

### 3.5 Secret Management

**Secret format:**
```
whsec_{base64_encoded_32_bytes}
```

Example: `whsec_K7x9mPqR2vN5hJ8wL4yB6cD3fG0iE1aT`

**Secret properties:**
- Length: 32 bytes (256 bits)
- Encoding: URL-safe Base64 (43 characters, no padding)
- Prefix: `whsec_` (for identification)

**Secret lifecycle:**
| Action | Process |
|--------|---------|
| Generation | Server-side, CSPRNG |
| Storage (CYBERCUBE) | Encrypted at rest |
| Storage (receiver) | Environment variable |
| Rotation | New secret, both valid temporarily |
| Revocation | Immediate invalidation |

### 3.6 Secret Rotation

Safe rotation process:
```
1. Generate new secret
2. Configure receiver with new secret
3. Update endpoint to use new secret
4. Verify new secret works
5. Remove old secret from receiver
```

During rotation (grace period):
- Both old and new secrets are valid
- Grace period: 24 hours
- Deliveries include both signatures (optional)

## 4. Delivery Mechanism

Webhooks are delivered via HTTPS POST with specific requirements.

### 4.1 HTTP Request Format

```http
POST /your-webhook-endpoint HTTP/1.1
Host: your-server.com
Content-Type: application/json
User-Agent: CYBERCUBE-Webhook/1.0
X-Webhook-ID: wh_1A2B3C4D5E6F7G8H
X-Webhook-Signature: sha256=abc123def456...
X-Webhook-Timestamp: 1737100000
X-Webhook-Event-Type: project.created
X-Webhook-Delivery-Attempt: 1

{
  "id": "evt_...",
  "type": "project.created",
  ...
}
```

### 4.2 Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| `Content-Type` | Yes | `application/json` |
| `User-Agent` | Yes | `CYBERCUBE-Webhook/1.0` |
| `X-Webhook-ID` | Yes | Unique delivery ID |
| `X-Webhook-Signature` | Yes | HMAC-SHA256 signature |
| `X-Webhook-Timestamp` | Yes | Unix timestamp |
| `X-Webhook-Event-Type` | Yes | Event type |
| `X-Webhook-Delivery-Attempt` | Yes | Attempt number (1-7) |

### 4.3 Endpoint Requirements

| Requirement | Specification |
|-------------|---------------|
| Protocol | HTTPS (TLS 1.2+) |
| Method | POST only |
| Timeout | Respond within 30 seconds |
| Success | Return 2xx status |
| Failure | Return 4xx/5xx or timeout |
| Body | Optional (ignored) |

### 4.4 IP Allowlisting (Optional)

CYBERCUBE webhook source IPs:
```
# Production
203.0.113.0/24
198.51.100.0/24

# List available at:
# https://api.cybercube.software/.well-known/webhook-ips
```

Receivers MAY allowlist these IPs for additional security.

### 4.5 Response Handling

| Response | Interpretation | Action |
|----------|---------------|--------|
| 200-299 | Success | Mark delivered |
| 301, 302 | Redirect | Follow (max 3 redirects) |
| 400 | Bad Request | No retry |
| 401 | Unauthorized | No retry |
| 403 | Forbidden | No retry |
| 404 | Not Found | No retry |
| 410 | Gone | No retry; disable endpoint |
| 429 | Too Many Requests | Retry with backoff |
| Other 4xx | Client error | No retry |
| 500-599 | Server error | Retry |
| Timeout | >30 seconds | Retry |
| Connection error | Network issue | Retry |

### 4.6 Success Response (Recommended)

```json
{
  "received": true,
  "event_id": "evt_1MqLi2J3K4L5M6N7O8P9Q0R1"
}
```

Body is optional but helps with debugging.

## 5. Retry Strategy

Failed deliveries are retried with exponential backoff.

### 5.1 Retry Schedule

| Attempt | Delay After Previous | Total Time |
|---------|---------------------|------------|
| 1 | Immediate | 0 |
| 2 | 1 minute | 1 minute |
| 3 | 5 minutes | 6 minutes |
| 4 | 30 minutes | 36 minutes |
| 5 | 2 hours | ~2.5 hours |
| 6 | 8 hours | ~10.5 hours |
| 7 | 24 hours | ~34.5 hours |

Maximum attempts: 7
Maximum retry window: ~34.5 hours

### 5.2 Retry Conditions

**Retry on:**
- HTTP 5xx response
- HTTP 429 (Too Many Requests)
- Connection timeout
- Connection refused
- DNS resolution failure
- TLS handshake failure

**Do NOT retry on:**
- HTTP 2xx (success)
- HTTP 400 (Bad Request)
- HTTP 401 (Unauthorized)
- HTTP 403 (Forbidden)
- HTTP 404 (Not Found)
- HTTP 410 (Gone) â€” also disables endpoint

### 5.3 Retry Headers

On retry, additional headers are included:

```http
X-Webhook-Delivery-Attempt: 3
X-Webhook-First-Attempt-At: 2026-01-17T12:00:00Z
X-Webhook-Retry-Count: 2
```

### 5.4 Dead Letter Queue (DLQ)

After all retries exhausted:
1. Event moved to DLQ
2. Endpoint status updated (may disable)
3. Alert sent to account admins
4. Event retained for 30 days

DLQ events can be:
- Manually replayed
- Inspected for debugging
- Exported for analysis

### 5.5 Endpoint Health

| Status | Condition | Delivery |
|--------|-----------|----------|
| Active | Normal operation | Enabled |
| Degraded | >50% failures in 1 hour | Enabled (alerted) |
| Disabled | >10 consecutive failures | Paused |
| Paused | Manually paused | Paused |

Automatic re-enable: After manual intervention or 24 hours (configurable)

## 6. Idempotency

Receivers MUST handle duplicate deliveries safely.

### 6.1 Why Duplicates Occur

- Network issues (ACK lost)
- Receiver timeout after processing
- Retry after transient failure
- System recovery/replay

### 6.2 Idempotency Implementation (Receiver)

```typescript
// Idempotency implementation example

interface ProcessedEvent {
  event_id: string;
  processed_at: Date;
  result: string;
}

class WebhookProcessor {
  private processedEvents: Map<string, ProcessedEvent> = new Map();
  // In production: use Redis, database, etc.
  
  async processWebhook(event: WebhookEvent): Promise<ProcessingResult> {
    // 1. Check if already processed
    const existing = await this.getProcessedEvent(event.id);
    if (existing) {
      console.log(`Event ${event.id} already processed at ${existing.processed_at}`);
      return { status: 'duplicate', original: existing };
    }
    
    // 2. Mark as processing (acquire lock)
    const locked = await this.acquireLock(event.id);
    if (!locked) {
      return { status: 'concurrent', message: 'Event being processed' };
    }
    
    try {
      // 3. Process the event
      const result = await this.handleEvent(event);
      
      // 4. Mark as processed
      await this.markProcessed(event.id, result);
      
      return { status: 'processed', result };
    } catch (error) {
      // 5. Release lock on failure (allow retry)
      await this.releaseLock(event.id);
      throw error;
    }
  }
  
  private async getProcessedEvent(eventId: string): Promise<ProcessedEvent | null> {
    // Check database/cache for processed event
    return this.processedEvents.get(eventId) || null;
  }
  
  private async acquireLock(eventId: string): Promise<boolean> {
    // Implement distributed lock (Redis SETNX, etc.)
    // TTL: 5 minutes (longer than processing time)
    return true;
  }
  
  private async markProcessed(eventId: string, result: string): Promise<void> {
    this.processedEvents.set(eventId, {
      event_id: eventId,
      processed_at: new Date(),
      result,
    });
  }
  
  private async handleEvent(event: WebhookEvent): Promise<string> {
    switch (event.type) {
      case 'project.created':
        return await this.handleProjectCreated(event.data.object);
      case 'invoice.paid':
        return await this.handleInvoicePaid(event.data.object);
      // ... other handlers
      default:
        return 'unhandled';
    }
  }
}
```

### 6.3 Idempotency Storage Schema

```sql
CREATE TABLE processed_webhook_events (
    event_id VARCHAR(30) PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    received_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ,
    processing_status VARCHAR(20) NOT NULL DEFAULT 'pending',
    result TEXT
);

-- Cleanup old records
CREATE INDEX idx_received_at ON processed_webhook_events (received_at);

-- Retention: 7 days (enough for retry window + buffer)
-- Cleanup job: DELETE WHERE received_at < NOW() - INTERVAL '7 days'
```

### 6.4 Idempotency Key Retention

| Environment | Retention |
|-------------|-----------|
| Receiver | 7 days minimum |
| CYBERCUBE | 30 days (in DLQ) |

## 7. Rate Limits

Webhook delivery and endpoint registration have rate limits.

### 7.1 Delivery Rate Limits

| Limit | Value | Scope |
|-------|-------|-------|
| Per endpoint | 1,000/minute | Single endpoint |
| Per account | 10,000/minute | All endpoints |
| Burst | 100/second | Per endpoint |

When exceeded:
- Events queued (not lost)
- Delivery delayed
- No retry penalty

### 7.2 Registration Rate Limits

| Operation | Limit |
|-----------|-------|
| Create endpoint | 10/hour |
| Update endpoint | 60/hour |
| Delete endpoint | 10/hour |
| Test endpoint | 30/hour |

### 7.3 Rate Limit Headers (Delivery)

```http
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 950
X-RateLimit-Reset: 1737100060
```

### 7.4 Receiver Rate Limiting

Receivers should handle bursts:

```typescript
// Rate limiting middleware example
import rateLimit from 'express-rate-limit';

const webhookLimiter = rateLimit({
  windowMs: 60 * 1000,        // 1 minute
  max: 1000,                   // Max requests
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    // Return 429 - CYBERCUBE will retry
    res.status(429).json({ error: 'Rate limit exceeded' });
  },
});

app.post('/webhooks/cybercube', webhookLimiter, webhookHandler);
```

## 8. Endpoint Management

Webhook endpoints are managed via API or dashboard.

### 8.1 Endpoint Object

```typescript
interface WebhookEndpoint {
  id: string;                    // WEB-XXXXXX-X
  url: string;                   // HTTPS callback URL
  description?: string;          // Human-readable description
  events: string[];              // Subscribed event types ['*'] or specific
  secret: string;                // Signing secret (write-only)
  status: EndpointStatus;        // active, paused, disabled
  
  // Metadata
  account_id: string;            // Owner account
  created_at: string;
  updated_at: string;
  
  // Health
  last_delivery_at?: string;
  last_success_at?: string;
  last_failure_at?: string;
  failure_count: number;
}

type EndpointStatus = 'active' | 'paused' | 'disabled';
```

### 8.2 Create Endpoint

```http
POST /api/v1/webhooks/endpoints
Authorization: Bearer {token}

{
  "url": "https://example.com/webhooks/cybercube",
  "description": "Production webhook handler",
  "events": ["project.created", "project.updated", "invoice.*"]
}
```

Response:
```json
{
  "data": {
    "id": "WEB-X2M8KD-7",
    "url": "https://example.com/webhooks/cybercube",
    "description": "Production webhook handler",
    "events": ["project.created", "project.updated", "invoice.*"],
    "secret": "whsec_K7x9mPqR2vN5hJ8wL4yB6cD3fG0iE1aT",
    "status": "active",
    "created_at": "2026-01-17T12:00:00Z"
  }
}
```

**Note:** Secret is only returned once at creation.

### 8.3 List Endpoints

```http
GET /api/v1/webhooks/endpoints
Authorization: Bearer {token}
```

### 8.4 Update Endpoint

```http
PATCH /api/v1/webhooks/endpoints/WEB-X2M8KD-7
Authorization: Bearer {token}

{
  "events": ["project.*", "task.*"],
  "status": "paused"
}
```

### 8.5 Rotate Secret

```http
POST /api/v1/webhooks/endpoints/WEB-X2M8KD-7/rotate-secret
Authorization: Bearer {token}
```

Response:
```json
{
  "data": {
    "secret": "whsec_N3wS3cr3tK3yH3r3ABC123XYZ",
    "previous_secret_valid_until": "2026-01-18T12:00:00Z"
  }
}
```

### 8.6 Test Endpoint

```http
POST /api/v1/webhooks/endpoints/WEB-X2M8KD-7/test
Authorization: Bearer {token}

{
  "event_type": "project.created"
}
```

Sends a test event with `livemode: false`.

### 8.7 Delete Endpoint

```http
DELETE /api/v1/webhooks/endpoints/WEB-X2M8KD-7
Authorization: Bearer {token}
```

### 8.8 Event Filtering

Filter patterns:
| Pattern | Matches |
|---------|---------|
| `*` | All events |
| `project.*` | All project events |
| `project.created` | Specific event |
| `invoice.payment.*` | Sub-resource events |

Multiple patterns: `["project.*", "task.created", "invoice.paid"]`

## 9. Event Replay & Recovery

Events can be replayed for recovery and debugging.

### 9.1 Replay Single Event

```http
POST /api/v1/webhooks/events/{event_id}/replay
Authorization: Bearer {token}

{
  "endpoint_id": "WEB-X2M8KD-7"
}
```

### 9.2 Replay Event Range

```http
POST /api/v1/webhooks/replay
Authorization: Bearer {token}

{
  "endpoint_id": "WEB-X2M8KD-7",
  "start_time": "2026-01-17T00:00:00Z",
  "end_time": "2026-01-17T12:00:00Z",
  "event_types": ["project.*"]
}
```

Limits:
- Max 1,000 events per replay request
- Rate limited to 10 requests/hour

### 9.3 List Failed Deliveries

```http
GET /api/v1/webhooks/endpoints/WEB-X2M8KD-7/failures
Authorization: Bearer {token}
```

Response includes:
- Event details
- Failure reason
- Attempt history
- Replay option

### 9.4 Delivery Logs

```http
GET /api/v1/webhooks/endpoints/WEB-X2M8KD-7/logs
Authorization: Bearer {token}

?start_time=2026-01-17T00:00:00Z
&end_time=2026-01-17T23:59:59Z
&status=failed
&limit=50
```

Log entry:
```json
{
  "id": "wh_1A2B3C4D5E",
  "event_id": "evt_...",
  "event_type": "project.created",
  "endpoint_id": "WEB-X2M8KD-7",
  "attempt": 1,
  "status": "failed",
  "http_status": 500,
  "response_time_ms": 1523,
  "error_message": "Internal Server Error",
  "created_at": "2026-01-17T12:00:00Z"
}
```

## 10. Security Best Practices

Security requirements for webhook implementations.

### 10.1 Receiver Security Checklist

**Required:**
- [ ] Verify signature on every request
- [ ] Validate timestamp within tolerance
- [ ] Use HTTPS with valid certificate
- [ ] Store secret securely (env var, secrets manager)
- [ ] Implement idempotency
- [ ] Return quickly (process async if needed)

**Recommended:**
- [ ] Allowlist CYBERCUBE IP ranges
- [ ] Use separate endpoint per environment
- [ ] Monitor for delivery anomalies
- [ ] Rotate secrets periodically
- [ ] Log all webhook receipts

### 10.2 Common Vulnerabilities

| Vulnerability | Mitigation |
|--------------|------------|
| Replay attack | Timestamp validation |
| Signature bypass | Always verify, timing-safe compare |
| MITM | HTTPS only, certificate validation |
| Secret exposure | Env vars, secrets manager |
| DoS via webhooks | Rate limiting, async processing |
| Injection | Validate and sanitize data |

### 10.3 Signature Verification Failures

Handle verification failures:

```typescript
app.post('/webhooks', (req, res) => {
  const result = verifyWebhookSignature(/* ... */);
  
  if (!result.valid) {
    // Log for security monitoring
    console.error('Webhook verification failed', {
      error: result.error,
      ip: req.ip,
      headers: sanitize(req.headers),
    });
    
    // Alert on repeated failures (potential attack)
    metrics.increment('webhook.verification.failed');
    
    // Return 401 (don't retry invalid signatures)
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process...
});
```

### 10.4 Async Processing Pattern

Process webhooks asynchronously for reliability:

```typescript
app.post('/webhooks', async (req, res) => {
  // 1. Verify signature
  const verified = verifyWebhookSignature(/* ... */);
  if (!verified.valid) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // 2. Parse and validate
  const event = JSON.parse(req.body);
  
  // 3. Quick acknowledgment
  res.status(200).json({ received: true });
  
  // 4. Queue for async processing
  await queue.add('process-webhook', {
    event_id: event.id,
    event_type: event.type,
    payload: event,
    received_at: new Date(),
  });
});

// Separate worker processes the queue
queue.process('process-webhook', async (job) => {
  const { event_id, event_type, payload } = job.data;
  
  // Check idempotency
  if (await isProcessed(event_id)) {
    return { status: 'duplicate' };
  }
  
  // Process event
  await handleEvent(event_type, payload);
  
  // Mark processed
  await markProcessed(event_id);
});
```

## 11. Implementation Reference

Complete reference implementation for webhook handling.

### 11.1 CYBERCUBE Webhook SDK (Sender)

```typescript
// webhook-service.ts - CYBERCUBE internal service

import crypto from 'crypto';

interface WebhookConfig {
  id: string;
  endpoint: string;
  secret: string;
  events: string[];
}

interface WebhookDelivery {
  id: string;
  event_id: string;
  endpoint_id: string;
  attempt: number;
  status: 'pending' | 'success' | 'failed';
  response_status?: number;
  response_time_ms?: number;
  error?: string;
  next_retry_at?: Date;
}

export class WebhookService {
  /**
   * Generate signing secret
   */
  static generateSecret(): string {
    const bytes = crypto.randomBytes(32);
    return 'whsec_' + bytes.toString('base64url');
  }
  
  /**
   * Sign webhook payload
   */
  static sign(payload: string, secret: string, timestamp: number): string {
    const signedPayload = `${timestamp}.${payload}`;
    const signature = crypto
      .createHmac('sha256', secret)
      .update(signedPayload, 'utf8')
      .digest('hex');
    return `sha256=${signature}`;
  }
  
  /**
   * Deliver webhook
   */
  async deliver(
    endpoint: WebhookConfig,
    event: WebhookEvent,
    attempt: number = 1
  ): Promise<WebhookDelivery> {
    const deliveryId = this.generateDeliveryId();
    const timestamp = Math.floor(Date.now() / 1000);
    const payload = JSON.stringify(event);
    const signature = WebhookService.sign(payload, endpoint.secret, timestamp);
    
    const startTime = Date.now();
    
    try {
      const response = await fetch(endpoint.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'CYBERCUBE-Webhook/1.0',
          'X-Webhook-ID': deliveryId,
          'X-Webhook-Signature': signature,
          'X-Webhook-Timestamp': timestamp.toString(),
          'X-Webhook-Event-Type': event.type,
          'X-Webhook-Delivery-Attempt': attempt.toString(),
        },
        body: payload,
        signal: AbortSignal.timeout(30000), // 30s timeout
      });
      
      const responseTime = Date.now() - startTime;
      
      if (response.ok) {
        return {
          id: deliveryId,
          event_id: event.id,
          endpoint_id: endpoint.id,
          attempt,
          status: 'success',
          response_status: response.status,
          response_time_ms: responseTime,
        };
      } else {
        return this.handleFailure(deliveryId, event, endpoint, attempt, {
          response_status: response.status,
          response_time_ms: responseTime,
          error: `HTTP ${response.status}`,
        });
      }
    } catch (error) {
      const responseTime = Date.now() - startTime;
      return this.handleFailure(deliveryId, event, endpoint, attempt, {
        response_time_ms: responseTime,
        error: error.message,
      });
    }
  }
  
  private handleFailure(
    deliveryId: string,
    event: WebhookEvent,
    endpoint: WebhookConfig,
    attempt: number,
    details: Partial<WebhookDelivery>
  ): WebhookDelivery {
    const nextRetry = this.calculateNextRetry(attempt);
    
    return {
      id: deliveryId,
      event_id: event.id,
      endpoint_id: endpoint.id,
      attempt,
      status: 'failed',
      next_retry_at: nextRetry,
      ...details,
    };
  }
  
  private calculateNextRetry(attempt: number): Date | undefined {
    const delays = [0, 60, 300, 1800, 7200, 28800, 86400]; // seconds
    if (attempt >= delays.length) {
      return undefined; // Max retries exceeded
    }
    return new Date(Date.now() + delays[attempt] * 1000);
  }
  
  private generateDeliveryId(): string {
    return 'wh_' + crypto.randomBytes(12).toString('hex');
  }
}
```

### 11.2 Receiver SDK (Client Library)

```typescript
// cybercube-webhooks.ts - Client SDK

import crypto from 'crypto';

export interface WebhookEvent {
  id: string;
  type: string;
  api_version: string;
  created_at: string;
  data: {
    object: any;
    previous_attributes?: any;
  };
  account_id: string;
  livemode: boolean;
}

export interface VerifyOptions {
  tolerance?: number;  // Seconds, default 300
}

export class CybercubeWebhooks {
  private secret: string;
  
  constructor(secret: string) {
    if (!secret.startsWith('whsec_')) {
      throw new Error('Invalid webhook secret format');
    }
    this.secret = secret;
  }
  
  /**
   * Verify and parse webhook
   */
  constructEvent(
    payload: string | Buffer,
    signature: string,
    timestamp: string,
    options: VerifyOptions = {}
  ): WebhookEvent {
    const tolerance = options.tolerance ?? 300;
    const payloadString = Buffer.isBuffer(payload) 
      ? payload.toString('utf8') 
      : payload;
    
    // Verify signature
    this.verifySignature(payloadString, signature, timestamp, tolerance);
    
    // Parse and return event
    return JSON.parse(payloadString);
  }
  
  private verifySignature(
    payload: string,
    signature: string,
    timestamp: string,
    tolerance: number
  ): void {
    // Validate signature format
    if (!signature.startsWith('sha256=')) {
      throw new WebhookSignatureError('Invalid signature format');
    }
    
    // Validate timestamp
    const ts = parseInt(timestamp, 10);
    if (isNaN(ts)) {
      throw new WebhookSignatureError('Invalid timestamp');
    }
    
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - ts) > tolerance) {
      throw new WebhookSignatureError('Timestamp outside tolerance');
    }
    
    // Compute expected signature
    const signedPayload = `${timestamp}.${payload}`;
    const expected = crypto
      .createHmac('sha256', this.secret)
      .update(signedPayload, 'utf8')
      .digest('hex');
    
    const received = signature.slice(7);
    
    // Timing-safe comparison
    if (!crypto.timingSafeEqual(
      Buffer.from(expected, 'hex'),
      Buffer.from(received, 'hex')
    )) {
      throw new WebhookSignatureError('Signature mismatch');
    }
  }
}

export class WebhookSignatureError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WebhookSignatureError';
  }
}

// Usage example
const webhooks = new CybercubeWebhooks(process.env.WEBHOOK_SECRET);

app.post('/webhooks', express.raw({ type: 'application/json' }), (req, res) => {
  try {
    const event = webhooks.constructEvent(
      req.body,
      req.headers['x-webhook-signature'],
      req.headers['x-webhook-timestamp']
    );
    
    // Handle event
    switch (event.type) {
      case 'project.created':
        handleProjectCreated(event.data.object);
        break;
      case 'invoice.paid':
        handleInvoicePaid(event.data.object);
        break;
    }
    
    res.json({ received: true });
  } catch (err) {
    if (err instanceof WebhookSignatureError) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: 'Internal error' });
    }
  }
});
```

### 11.3 Database Schema

```sql
-- CYBERCUBE Webhook Schema (PostgreSQL)

-- Webhook endpoints
CREATE TABLE webhook_endpoints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    public_id VARCHAR(16) NOT NULL UNIQUE,  -- WEB-XXXXXX-X
    account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
    url TEXT NOT NULL,
    description TEXT,
    events TEXT[] NOT NULL DEFAULT '{"*"}',
    secret_hash VARCHAR(64) NOT NULL,       -- SHA-256(secret)
    secret_hint VARCHAR(10),                -- Last 4 chars for UI
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    
    -- Health tracking
    failure_count INTEGER NOT NULL DEFAULT 0,
    last_delivery_at TIMESTAMPTZ,
    last_success_at TIMESTAMPTZ,
    last_failure_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    CONSTRAINT valid_status CHECK (status IN ('active', 'paused', 'disabled'))
);

CREATE INDEX idx_endpoints_account ON webhook_endpoints (account_id);
CREATE INDEX idx_endpoints_status ON webhook_endpoints (status);

-- Webhook events (source of truth)
CREATE TABLE webhook_events (
    id VARCHAR(30) PRIMARY KEY,              -- evt_...
    type VARCHAR(100) NOT NULL,
    api_version VARCHAR(20) NOT NULL,
    account_id UUID NOT NULL REFERENCES accounts(id),
    livemode BOOLEAN NOT NULL DEFAULT true,
    data JSONB NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_events_account_time ON webhook_events (account_id, created_at DESC);
CREATE INDEX idx_events_type ON webhook_events (type);

-- Delivery attempts
CREATE TABLE webhook_deliveries (
    id VARCHAR(30) PRIMARY KEY,              -- wh_...
    event_id VARCHAR(30) NOT NULL REFERENCES webhook_events(id),
    endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id) ON DELETE CASCADE,
    attempt INTEGER NOT NULL DEFAULT 1,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    
    -- Response details
    response_status INTEGER,
    response_time_ms INTEGER,
    response_body TEXT,
    error_message TEXT,
    
    -- Retry scheduling
    scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    delivered_at TIMESTAMPTZ,
    next_retry_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    CONSTRAINT valid_status CHECK (status IN ('pending', 'success', 'failed', 'exhausted'))
);

CREATE INDEX idx_deliveries_endpoint_time ON webhook_deliveries (endpoint_id, created_at DESC);
CREATE INDEX idx_deliveries_retry ON webhook_deliveries (status, next_retry_at) WHERE status = 'failed';
CREATE INDEX idx_deliveries_event ON webhook_deliveries (event_id);

-- Dead letter queue
CREATE TABLE webhook_dlq (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id VARCHAR(30) NOT NULL REFERENCES webhook_events(id),
    endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id),
    failure_reason TEXT NOT NULL,
    attempts_summary JSONB NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    replayed_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '30 days'
);

CREATE INDEX idx_dlq_endpoint ON webhook_dlq (endpoint_id);
CREATE INDEX idx_dlq_expires ON webhook_dlq (expires_at);
```

---

## CYBERCUBE Webhooks â€” Developer Cheat Sheet

Print it. Pin it. Reference it.

ðŸ”¹ Webhook Structure

```json
{
  "id": "evt_...",
  "type": "project.created",
  "api_version": "2026-01-17",
  "created_at": "2026-01-17T12:00:00Z",
  "data": {
    "object": {...},
    "previous_attributes": {...}
  },
  "account_id": "ACC-...",
  "livemode": true
}
```

ðŸ”¹ Signature Verification

```typescript
// 1. Get headers
const signature = req.headers['x-webhook-signature'];
const timestamp = req.headers['x-webhook-timestamp'];

// 2. Check timestamp (< 5 min old)
const age = Math.floor(Date.now() / 1000) - parseInt(timestamp);
if (age > 300) throw new Error('Too old');

// 3. Compute expected signature
const expected = 'sha256=' + crypto
  .createHmac('sha256', secret)
  .update(timestamp + '.' + body)
  .digest('hex');

// 4. Timing-safe compare
crypto.timingSafeEqual(
  Buffer.from(signature.slice(7), 'hex'),
  Buffer.from(expected.slice(7), 'hex')
);
```

ðŸ”¹ Required Headers

| Header | Description |
|--------|-------------|
| `X-Webhook-Signature` | `sha256=...` |
| `X-Webhook-Timestamp` | Unix seconds |
| `X-Webhook-ID` | Delivery ID |
| `X-Webhook-Event-Type` | Event type |
| `X-Webhook-Delivery-Attempt` | Attempt # |

ðŸ”¹ Retry Schedule

```
Attempt 1: Immediate
Attempt 2: +1 minute
Attempt 3: +5 minutes
Attempt 4: +30 minutes
Attempt 5: +2 hours
Attempt 6: +8 hours
Attempt 7: +24 hours
```

ðŸ”¹ Response Handling

| Response | Action |
|----------|--------|
| 2xx | Success, done |
| 4xx | Fail, no retry* |
| 5xx | Fail, retry |
| Timeout | Fail, retry |

*Except 429 (retry with backoff) and 410 (disables endpoint)

ðŸ”¹ Idempotency

```typescript
// Track processed events
if (await isProcessed(event.id)) {
  return res.status(200).json({ received: true });
}

// Process once
await handleEvent(event);
await markProcessed(event.id);
```

ðŸ”¹ Event Types

```
{resource}.created
{resource}.updated
{resource}.deleted
{resource}.{action}
{resource}.{subresource}.{action}

Examples:
project.created
invoice.paid
invoice.payment.failed
```

ðŸ”¹ Secret Format

```
whsec_K7x9mPqR2vN5hJ8wL4yB6cD3fG0iE1aT
      â””â”€â”€ 32 bytes base64url â”€â”€â”˜
```

ðŸ”¹ Async Processing Pattern

```typescript
app.post('/webhooks', async (req, res) => {
  // 1. Verify (sync)
  const event = verifyWebhook(req);
  
  // 2. ACK immediately
  res.status(200).json({ received: true });
  
  // 3. Queue for async processing
  await queue.add('webhook', event);
});
```

ðŸ”¹ Security Checklist

âœ… Verify signature EVERY request
âœ… Check timestamp < 5 minutes
âœ… Use timing-safe comparison
âœ… HTTPS only
âœ… Store secret in env/secrets manager
âœ… Implement idempotency
âœ… Respond within 30 seconds

ðŸ”¹ What You MUST NOT Do

âŒ Skip signature verification
âŒ Use == for signature compare
âŒ Process before ACK (blocks)
âŒ Log full webhook secret
âŒ Trust webhook without verify
âŒ Ignore duplicates

ðŸ”¹ Endpoint Requirements

```
Protocol: HTTPS (TLS 1.2+)
Method:   POST
Timeout:  30 seconds
Success:  Return 2xx
```

ðŸ”¹ Event Filtering

```
*              â†’ All events
project.*      â†’ All project events
project.created â†’ Specific event
invoice.payment.* â†’ Sub-resource
```

---

## Implementation Status

**Last Updated:** 2026-01-17
**Standard Version:** v1

### Core Implementation

| Component | Status | Notes |
|-----------|--------|-------|
| Event Schema | PENDING | Define all events |
| Webhook Signing | PENDING | HMAC-SHA256 |
| Delivery Engine | PENDING | Queue-based |
| Retry Logic | PENDING | Exponential backoff |
| Endpoint Management API | PENDING | CRUD endpoints |
| Dead Letter Queue | PENDING | 30-day retention |
| Delivery Logs | PENDING | Query API |
| Event Replay | PENDING | Manual trigger |
| SDK (TypeScript) | PENDING | Client library |

### Migration Path

1. **Phase 1**: Event schema + signing
2. **Phase 2**: Delivery engine + retries
3. **Phase 3**: Endpoint management API
4. **Phase 4**: Monitoring + DLQ
5. **Phase 5**: SDK + documentation

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v1 | 2026-01-17 | Initial release |
