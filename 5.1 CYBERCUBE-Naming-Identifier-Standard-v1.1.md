# CYBERCUBE Naming & Identifier Standard (v1.1)

**Status:** Active  
**Effective:** 2026-01-17  
**Classification:** INTERNAL  
**Owner:** Engineering Lead  
**Review Cycle:** Annual + on major version change

**Quick links:** [Glossary](#glossary) ¬∑ [0. Purpose](#0-purpose--design-principles) ¬∑ [1. Artifact Naming](#1-namespace-a--artifact-naming) ¬∑ [2. Public Entity IDs](#2-namespace-b--public-entity-ids-cc-pid-v1) ¬∑ [3. Implementation](#3-implementation-guidelines) ¬∑ [4. Tables](#4-tables) ¬∑ [5. Tickets vs WOE](#5-ticket-vs-issue-woe-separation) ¬∑ [Cheat Sheet](#developer-cheat-sheet) ¬∑ [Appendix A: Support SOP](#appendix-a-support-sop--reading-and-collecting-public-entity-ids-cc-pid) ¬∑ [Implementation Status](#implementation-status)

---

## Glossary

This glossary defines key terms used throughout the CYBERCUBE Naming & Identifier Standard. All definitions are **normative** unless stated otherwise.

### A

#### ACC (Account)

A top-level organizational entity representing a customer account, tenant, or organization within
CYBERCUBE systems.

An ACC may own users, projects, billing records, and configurations.

| Property | Value |
|----------|-------|
| **Entity Code** | ACC |
| **Notes** | Canonical replacement for "Organization". Used for multi-tenant scoping. Never reused once assigned. |

#### Artifact

Any non-database object produced or managed during software development or operations, including:
- Source files
- Repositories
- Branches
- Build outputs
- Deployment artifacts
- Documentation files

Artifacts use **Namespace A** (Artifact Naming) and may include mutable metadata (version, date, environment).

#### Authentication (AuthN)

The process of verifying the identity of a user or system actor (e.g., via password, OAuth, SSO, magic link).

‚ö†Ô∏è **Critical:** Public Entity IDs MUST NOT be used for authentication.

#### Authorization (AuthZ)

The process of determining what actions an authenticated user or system is allowed to perform.

‚ö†Ô∏è **Critical:** Public Entity IDs MUST NOT be used for authorization or permission checks.

### C

#### Check Digit (CHK)

A single-character suffix derived deterministically from an entity code and token, appended to all Public Entity IDs.

**Purpose:**
- ‚úÖ Detect transcription and manual entry errors
- ‚ùå Not cryptographic
- ‚ùå Not a security feature
- ‚úÖ Mandatory in CC-PID v1

**Example:** `INV-4Q7T9P-N`

#### Client (CLT)

A customer entity representing a business or individual receiving services.

| Property | Value |
|----------|-------|
| **Entity Code** | CLT |
| **Relationship** | Typically associated with one ACC |
| **Data Access** | May own projects, invoices, and contacts |

---

### E

#### Entity

A persistent domain object stored in a database and represented by an internal identifier (e.g., UUID) and a Public Entity ID.

**Examples:**
- Account
- User
- Project
- Invoice

Entities use **Namespace B** (Public Entity IDs).

#### Entity Code

A fixed, three-letter uppercase code identifying the type of a Public Entity.

**Examples:** `ACC`, `USR`, `PRJ`, `INV`

**Properties:**
- ‚úÖ Immutable
- ‚úÖ Never reused
- ‚úÖ Used only for classification and routing

#### Environment (Artifact Context)

A deployment or execution context such as:
- **DEV** (Development)
- **STG** (Staging)
- **PRD** (Production)

Used only in artifact naming suffixes.

> ‚ö†Ô∏è **Note:** This is distinct from the ENV Public Entity code.

#### Environment (Entity)

A database entity representing a logical or physical environment configuration.

‚ö†  Note:

The Entity Code "ENV" is used for system configuration records only and it‚Äôs unrelated to
artifact environment suffixes

---

### G

#### Governance Rules

Mandatory policies that define how naming, identifiers, and codes are created, managed, and preserved over time.

**Key principles:**
- ‚úÖ Immutability
- ‚úÖ No reuse
- ‚úÖ Central registry
- ‚úÖ Server-side generation

---

### I

#### Identifier (ID)

A value used to uniquely reference an object.

**In CYBERCUBE, two main types exist:**

| Type | Scope | Visibility |
|------|-------|------------|
| **Internal ID** (e.g., UUIDv7) | System-only | Hidden |
| **Public Entity ID** | User-facing | Exposed |

#### Immutability

The principle that once assigned, an identifier or code must never change.

**Applies to:**
- ‚úÖ Public Entity IDs
- ‚úÖ Entity Codes
- ‚úÖ Historical references

---

### N

#### Namespace

A logical partition defining naming rules, formats, and constraints.

**CYBERCUBE defines two namespaces:**

| Namespace | Purpose | Mutability |
|-----------|---------|------------|
| **Namespace A** | Artifact Naming | Mutable |
| **Namespace B** | Public Entity IDs (CC-PID) | Immutable |

‚ö†Ô∏è **Critical:** Namespaces must never be mixed.

---

### P

#### Permission (PRM)

A granular access rule defining an allowed action within the system.

> ‚ö†Ô∏è **Critical:** The Entity Code "PRM" is used in authorization systems and must NEVER be inferred from Public Entity IDs.

#### Policy (POL)

A higher-level rule or configuration governing system behavior or access control.

| Property | Value |
|----------|-------|
| **Entity Code** | POL |
| **Examples** | Security policies, access policies |

#### Public Entity ID (CC-PID)

A human-readable, non-sensitive identifier used to reference entities externally.

**Canonical format:** `<ENTITY>-<TOKEN>-<CHK>`

**Example:** `PRJ-X2M8KD-F`

**Properties:**
- ‚úÖ Safe to expose
- ‚úÖ Immutable
- ‚ùå Not a secret
- ‚ùå Not proof of identity or access

---

### R

#### Reusable Standard Module (RSM)

A top-level project classification for versioned, governed, standalone modules designed to be reused across multiple future projects. RSMs are productized internal assets that sit between one-off projects and product/platform deliverables.

**Classification:**
- ‚ùå Not a one-off project
- ‚ùå Not a product or platform
- ‚úÖ A certified building block

**Governance:** Versioned, standalone, subject to certification and reuse governance.

---

### T

#### Token

The random component of a Public Entity ID.

**Properties:**
- ‚úÖ Generated using a human-safe alphabet
- ‚úÖ No semantic meaning
- ‚úÖ Unique per (entity_code, token) pair

---

### U

#### User (USR)

An individual human or service account that can authenticate into the system.

| Property | Value |
|----------|-------|
| **Entity Code** | USR |
| **Features** | Belongs to an ACC; Subject to roles and permissions |

---

### V

#### Versioning

The practice of evolving standards while preserving backward compatibility.

**Current standard:** CC-PID v1

**Future changes:** Require a major version increment. All prior versions remain valid indefinitely.

---

## 0. Purpose & Design Principles

| | |
|---|---|
| **Status** | Active |
| **Applies to** | All CYBERCUBE products, services, repositories, databases, and integrations |

This standard defines how names and identifiers are created, used, governed, and validated
across CYBERCUBE systems. This document unifies CYBERCUBE‚Äôs  artifact naming
convention and the new Public Entity ID  scheme under a single standard. This standard does
not define authentication mechanisms, authorization models, encryption schemes, or API
security patterns.

Design principles:


‚Ä¢ Separation of concerns (naming ‚â† identifying ‚â† authorization)

‚Ä¢ Human-safe but system-rigorous identifiers

‚Ä¢ Immutability for external references

‚Ä¢ Auditability & future-proofing

It defines two namespaces that must never be confused:

‚Ä¢ Namespace A ‚Äî Artifact Naming (files, repos, branches, tickets-as-artifacts, and other

build or release artifacts.)

‚Ä¢ Namespace B ‚Äî Public Entity Identifiers (CC-PID) used for user‚Äëfacing identifiers stored in

databases (clients, projects, invoices, etc.).

These namespaces MUST NOT be mixed.

Each namespace has its own pattern and rules but shares a common code registry and governance process. Keeping the namespaces separate prevents mutable metadata (like version or date) from leaking into IDs that must remain immutable.

---

## 1. Namespace A ‚Äî Artifact Naming

Artifacts include files, repositories, branches, CI/CD outputs, release packages, documentation, and internal issue tracker keys. They encode metadata such as the project name, semantic version and environment directly in their names. This section preserves the existing naming conventions and examples.

‚ö†Ô∏è **Important:** Artifact names may change over time. They are not identifiers.

### Artifact Naming Flow

1. **Assign PARENT + SUB codes** (domain classification)
2. **Add Project Name** (human-readable)
3. **Add mutable metadata:** Version (SemVer), Date (YYYYMMDD), Environment (DEV/STG/PRD)
4. **Result:** e.g., `WA-SS_MyApp_v1.2.0_20250116_PRD.zip`

### 1.1 Pattern

```
<PARENT>-<SUB>_<ProjectName>_v<SemVer>_<YYYYMMDD>_<ENV>.<ext>
```

‚Ä¢ `<PARENT>`:¬†2‚Äì3‚ÄØcharacter top‚Äëlevel code (uppercase).

‚Ä¢ `<SUB>`:¬†2‚Äì3‚ÄØcharacter subtype code (uppercase; digits allowed).

‚Ä¢ `<ProjectName>`:¬†alphanumeric with dashes only (A‚ÄìZ, 0‚Äì9 and `-`).

‚Ä¢ `<SemVer>`:¬†semantic version as `MAJOR.MINOR.PATCH` (e.g. `1.4.0`).

‚Ä¢ `<YYYYMMDD>`:¬†build/release date in UTC (e.g. `20251106`).

‚Ä¢ `<ENV>`:¬†environment: one of `DEV`, `STG`, `PRD`, `OPS`, `LAB`.

‚Ä¢ `<ext>`:¬†standard file extension (md, pdf, json, zip, apk, ipa, yml, etc.).

### 1.2 Validation Regex

**For filenames (with extension):**

```
^(WA|MA|DA|CS|AP|A1|DT|DC|SC|I1|GM|BC|RP|IN|MN|CM|QA)-[A-Z0-9]{2,3}_[A-Z0-9-]+_v[0-9]+\.[0-9]+\.[0-9]+_[0-9]{8}_(DEV|STG|PRD|OPS|LAB)\.[A-Za-z0-9]+$
```

**For parent‚Äìsubtype codes only (folder or tag):**

```
^(WA|MA|DA|CS|AP|A1|DT|DC|SC|I1|GM|BC|RP|IN|MN|CM|QA)-[A-Z0-9]{2,3}$
```

### 1.3 Examples

**Files:**
- `WA-EC_EXP-PORTAL_v1.2.0_20251106_PRD.md`
- `A1-NL_CHAT-ASSIST_v0.6.3_20251106_STG.json`
- `DC-CD_PIPELINE_v2.0.0_20251106_OPS.yml`

**Branch:**
- `feature/MA-XP_NewAuthFlow_v0.3.0`

### 1.4 Ticket / Internal Issue as Artifact (WOE ‚Äî Work-Oriented Entries)

These are referred to as **Work-Oriented Entries (WOE)**. Internal engineering work items (bugs, chores, refactors) are artifacts, not entities. They are sequential or tracker-generated, used in branches, commits, sprint board.

‚ö†Ô∏è **Critical:** WOE are NOT exposed to customers and do NOT appear in URLs, emails, invoices, exports, or webhooks.

**Examples:**
- `CS-ER-1427`
- `AP-RS-0913`

---

## 2. Namespace B ‚Äî Public Entity IDs (CC-PID v1)

Public Entity IDs are human-friendly, user-facing identifiers for database entities that are externally referenced.

**Used in:**
- UIs
- URLs
- Invoices
- PDFs
- Exports
- APIs
- Support tickets

**Properties:**
- ‚úÖ Immutable
- ‚úÖ Non-semantic
- ‚úÖ Safe to share publicly
- ‚ùå Never used for authentication
- ‚ùå Never used for authorization

‚ö†Ô∏è **Critical:** They are labels, not secrets.

### Generation Flow

```
Entity Created (e.g., Project)
    ‚Üì
Assign ENTITY CODE (ACC, PRJ, INV, etc.)
    ‚Üì
Generate Random TOKEN (Base32, human-safe)
    ‚Üì
Compute Check Digit (CHK) - Deterministic typo guard
    ‚Üì
Persist Public Entity ID: PRJ-X2M8KD-F (Immutable forever)
```

### 2.1 Canonical Format (check digit required)

```
<ENTITY>-<TOKEN>-<CHK>
```

**Example:** `PRJ-X2M8KD-F`

#### 1. `<ENTITY>` Component

**Format:** Exactly 3 uppercase letters that identify the type of entity

**Examples:** `CLT` (client), `PRJ` (project), `INV` (invoice)

**Rules:**
- ‚úÖ Uppercase only
- ‚úÖ Centrally registered
- ‚úÖ Never reused
- ‚ùå Must NOT encode business logic

**Case Handling:**
- Stored and displayed in **UPPERCASE**
- Input MAY be accepted case-insensitively
- Validators MUST normalize to uppercase before parsing and checksum validation

#### 2. `<TOKEN>` Component

**Format:** 6- or 8-character random string

**Alphabet (human-safe Base32):**
```
ABCDEFGHJKLMNPQRSTUVWXYZ23456789
```

‚ö†Ô∏è **Note:** Excludes `I`, `O`, `0`, `1` to prevent confusion

‚Ä¢ Internationalization (Normative): The CC-PID alphabet is ASCII-only and is safe across all

locales and keyboards. Systems MUST treat CC-PID values as UTF-8 strings at
boundaries, but MUST normalize by trimming and uppercasing using locale-invariant rules
(ASCII semantics) before validation. Non-ASCII lookalike characters (e.g., Unicode
homoglyphs) MUST be rejected by the validation regex.

‚Ä¢ The token MUST be generated using a cryptographically secure random number generator

(CSPRNG) and MUST NOT use non-cryptographic randomness (e.g., Math.random()).

‚Ä¢ The token MUST have no semantic meaning.

‚Ä¢ Default length is 6 characters; high-volume entity types (e.g., AUD, LOG, JOB) MUST use 8

characters.

‚Ä¢ Future versioning reserve (Guidance): CC-PID v1 does not embed a version marker inside

the ID. However, CYBERCUBE reserves the right to introduce a future ‚ÄúToken Version
Prefix‚Äù by reserving the first token character for a version indicator if a breaking format
change is ever required. If activated in a future major version, v1 IDs remain valid
indefinitely and validation MUST accept both formats by version-aware parsing.

‚Ä¢ Capacity guidance (non-normative): 6 characters yields 32^6 = 1,073,741,824 possible

tokens (~1.07B) per entity code; 8 characters yields 32^8 = 1,099,511,627,776 (~1.1T). Use
8 characters for very high-volume entities, long-lived systems, or when manual imports/
backfills may create large record counts over time.

3. <CHK>

‚Ä¢ a single character check digit from the same alphabet, derived from `<ENTITY><TOKEN>`

to catch typos.

‚Ä¢ It is mandatory and deterministic.

‚Ä¢ Not cryptographic.

‚Ä¢ Not a security control.

‚Ä¢ QR compatibility (Guidance): CC-PIDs are QR-friendly because they are short, ASCII, and

restricted to a stable alphanumeric alphabet. Systems MAY render CC-PIDs as QR codes in
invoices, printed documents, or support workflows.

Example: CLT-9F4K7Q-F.

#### 2.1.1 Check Digit Rationale

The check digit is not a security feature. It exists solely to detect transcription errors when IDs are read over the phone or copied from screenshots. Always derive the check digit deterministically on the server side.

#### 2.1.2 Mandatory Check Digit Algorithm (CC-PID v1)

‚ö†Ô∏è **Critical:** All CC-PID v1 implementations MUST use the SHA-256 algorithm specified below to ensure cross-language and cross-service interoperability.

**Algorithm:**
```
CHK = alphabet[ SHA256(entity + "|" + token)[0] mod 32 ]
```

**Where:**
- `entity` = 3-letter entity code (uppercase)
- `token` = 6 or 8 character random token
- `SHA256()` = SHA-256 hash function
- `[0]` = first byte of the hash digest
- `mod 32` = modulo 32 (alphabet length)
- `alphabet` = `ABCDEFGHJKLMNPQRSTUVWXYZ23456789`

**Rationale:**
- SHA-256 is universally available in all programming languages
- Deterministic output ensures consistent results across all implementations
- First byte provides sufficient entropy for check digit purposes
- Simple modulo operation maps to alphabet range

**Example Calculation:**
```
Entity: "PRJ"
Token: "X2M8KD"
Input: "PRJ|X2M8KD"
SHA256: [first byte] = 0x05 = 5
5 mod 32 = 5
alphabet[5] = "F"
Result: PRJ-X2M8KD-F
```

**Implementation Requirements:**
- MUST use SHA-256 (not SHA-1, MD5, or other hash functions)
- MUST use UTF-8 encoding for input string
- MUST use pipe character "|" as separator
- MUST use first byte (index 0) of digest
- MUST apply modulo 32 before alphabet lookup

**Cross-Language Interoperability:**

All implementations in any programming language MUST produce identical check digits for the same input. This ensures that:
- A Python service can validate IDs generated by a TypeScript service
- A Go service can validate IDs generated by a Java service
- Client-side JavaScript can validate server-generated IDs
- All services in a distributed system produce consistent results

**Test Vectors (Normative):**

Implementations MUST pass these test cases:

| Entity | Token | Expected CHK | Full CC-PID |
|--------|-------|--------------|-------------|
| PRJ | X2M8KD | F | PRJ-X2M8KD-F |
| CLT | 9F4K7Q | F | CLT-9F4K7Q-F |
| INV | 4Q7T9P | N | INV-4Q7T9P-N |
| USR | 7M3KPQ | M | USR-7M3KPQ-M |
| TKT | 2R7W9D | U | TKT-2R7W9D-U |

**Future Algorithm Versions:**

If a future version of CC-PID requires a different check digit algorithm:
- It will be designated CC-PID v2 (or higher)
- All v1 IDs remain valid indefinitely
- Services MUST support validation of all version formats
- The version MAY be indicated by a reserved character in the token (future specification)

---

### 2.2 Allowed and Forbidden Uses

Public IDs  may be used  anywhere a human or external system needs to refer to an entity
safely: UI labels, URLs, invoices, support tickets, exports, logs and webhooks payloads,
support communication.

Canonical URL format (Guidance): When embedding Public Entity IDs in product URLs, use the
pattern `/{entity-plural}/{CC-PID}` (example: `/projects/PRJ-X2M8KD-F`, `/clients/CLT-9F4K7Q-F`). The path segment is a human-friendly resource name; the authoritative identifier is the CC-PID.

**REST Resources**

```
GET /api/v1/projects/PRJ-X2M8KD-F
GET /api/v1/invoices/INV-4Q7T9P-N
GET /api/v1/users/USR-7M3KPQ-M
```

**Customer-facing URLs**

```
https://app.cybercube.software/projects/PRJ-X2M8KD-F
https://app.cybercube.software/invoices/INV-4Q7T9P-N
```

Hierarchical URL references (Guidance, URL-only): For nested resources, URLs MAY use a
parent/child reference by concatenating CC-PIDs with a slash for routing clarity (example: `/ projects/PRJ-X2M8KD-F/tasks/TSK-9F4K7Q-2` or compact form `PRJ-X2M8KD-F/ TSK-9F4K7Q-2`). This is for URL composition only; CC-PIDs MUST remain flat identifiers in
storage (no embedded hierarchy) and MUST NOT be stored as concatenated path strings.

Public IDs  must not be used  for authentication, authorization, permission checks or capability
grants because Public Entity IDs MUST NOT be treated as capabilities or access tokens.
Possession of an ID alone MUST NEVER grant access to data or actions.

Voice readability (Guidance): For phone support, CC-PIDs MAY be read using the NATO
phonetic alphabet for letters (A=Alpha, B=Bravo, C=Charlie, D=Delta, E=Echo, F=Foxtrot,
G=Golf, H=Hotel, J=Juliett, K=Kilo, L=Lima, M=Mike, N=November, P=Papa,
Q=Quebec, R=Romeo, S=Sierra, T=Tango, U=Uniform, V=Victor, W=Whiskey, X=X-ray,
Y=Yankee, Z=Zulu). Digits are read as spoken numbers (2‚Äì9).

> **Note:** I (India) and O (Oscar) are excluded from the CC-PID token alphabet and will never
> appear in tokens or check digits. If a customer reads "I" or "O", treat it as a likely
> transcription error and ask them to re-verify. The full NATO alphabet is provided in
> Appendix A for support reference.

1. Not secret ¬†‚Äì¬†public IDs are deliberately exposed in URLs and documents, so anyone can

obtain them.

2. Guessable ¬†‚Äì¬†even with a large namespace, random IDs leak via screenshots and logs;
   security must never rely on obscurity.
3. No identity proof ¬†‚Äì¬†knowing an ID proves only that someone has seen it, not that they are
   authorized to act on that entity.  Possession ‚â† identity
4. No policy context ¬†‚Äì¬†authorization requires user/session roles and ownership checks, not an
   entity label.
5. Check digit ‚â† crypto ¬†‚Äì¬†the mandatory check digit only detects typos; it is not a
   cryptographic signature.

Use proper authentication (passwords, magic links, OAuth, SSO) and authorization (role‚Äëbased
or attribute‚Äëbased access control) systems to protect data. Email verification and passwordless
login flows MUST use separate secret, time-limited, single-use verification tokens; Public Entity
IDs (e.g., USR-*) may appear only as non-authoritative context and MUST NOT be used as
verification proofs

Partial ID search (Guidance): When implementing search-by-ID in UIs, accept only prefix
matches of the `<TOKEN>` portion and require a minimum of 3 characters after the entity code.
Example: allow searching `PRJ-X2M` to match `PRJ-X2M8KD-F`. Do not implement arbitrary
substring search for IDs to reduce accidental matches and enumeration risk.

### 2.3 Uniqueness Model

#### 2.3.1 Current Model: Per-Entity-Type Uniqueness (CC-PID v1)

The `<TOKEN>` must be unique **within its entity type**. This means `CLT-9F4K7Q-F` and `PRJ-9F4K7Q-4` may coexist because they refer to different entity types.

**Implementation:**
- Store `entity_code` and `public_token` separately
- Add unique index on `(entity_code, public_token)`
- Collision detection scoped per entity type

**Advantages:**
- ‚úÖ Smaller collision probability per entity type
- ‚úÖ Simpler database constraints
- ‚úÖ Faster uniqueness checks (smaller index per entity)
- ‚úÖ Natural partitioning by entity type

**Disadvantages:**
- ‚ö†Ô∏è Same token can appear in different entity types
- ‚ö†Ô∏è Potential user confusion when seeing similar tokens
- ‚ö†Ô∏è Cannot use token alone for lookups

#### 2.3.2 Alternative Model: Global Token Uniqueness (Recommended for v2)

For enhanced user experience and system simplicity, implementations MAY enforce **global token uniqueness** across all entity types.

**Implementation:**
- Add unique index on `public_token` alone (across all tables)
- OR use a centralized token registry table
- Collision detection across entire system

**Advantages:**
- ‚úÖ Each token is globally unique
- ‚úÖ Reduced user confusion
- ‚úÖ Simpler mental model
- ‚úÖ Can lookup by token alone (faster routing)
- ‚úÖ Better for distributed systems
- ‚úÖ Easier debugging and support

**Disadvantages:**
- ‚ö†Ô∏è Slightly higher collision probability (shared namespace)
- ‚ö†Ô∏è More complex database constraints (cross-table)
- ‚ö†Ô∏è Requires coordination in distributed generation

**Collision Probability Analysis:**

Per-generation collision probability (existing_count / namespace_size) with 6-character tokens and global uniqueness:
- Namespace: 32^6 = 1,073,741,824 (~1.07 billion)
- At 1 million total entities across all types: ~0.09% collision probability per generation
- At 10 million total entities: ~0.93% collision probability per generation
- At 100 million total entities: ~9.3% collision probability per generation

**Recommendation:** Use 8-character tokens for global uniqueness (32^8 = ~1.1 trillion combinations).

#### 2.3.3 Migration Path

**For New Implementations:**
Consider global token uniqueness from the start:
1. Use 8-character tokens by default
2. Implement global token registry or cross-table unique constraint
3. Retry generation on collision (up to 10 attempts)

**For Existing Implementations:**
Maintain per-entity-type uniqueness (backward compatible):
1. Continue with current model
2. Plan migration to global uniqueness in future version
3. Use longer tokens (8 chars) for high-volume entities

**Database Schema for Global Uniqueness:**

```sql
-- Option 1: Centralized token registry
CREATE TABLE public_id_tokens (
    token VARCHAR(8) PRIMARY KEY,
    entity_code CHAR(3) NOT NULL,
    entity_table VARCHAR(50) NOT NULL,
    entity_pk UUID NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_tokens_entity ON public_id_tokens(entity_code, entity_table, entity_pk);

-- Option 2: Cross-table unique constraint (PostgreSQL)
CREATE UNIQUE INDEX global_token_unique 
    ON public_id_tokens (token);
```

**CC-PID v1 Compliance:**

Both models are compliant with CC-PID v1 specification. The choice is an implementation decision based on system requirements.

**Decision Matrix:**

| Factor | Per-Entity-Type | Global Uniqueness |
|--------|-----------------|-------------------|
| **User Experience** | ‚ö†Ô∏è Duplicate tokens possible | ‚úÖ All tokens unique |
| **Database Complexity** | ‚úÖ Simple per-table constraints | ‚ö†Ô∏è Requires coordination |
| **Lookup Performance** | ‚úÖ Fast (scoped index) | ‚úÖ Fast (can skip entity type) |
| **Collision Probability** | ‚úÖ Lower (smaller namespace) | ‚ö†Ô∏è Higher (shared namespace) |
| **Distributed Systems** | ‚ö†Ô∏è Requires entity-aware routing | ‚úÖ Simpler coordination |
| **Support/Debugging** | ‚ö†Ô∏è Must specify entity type | ‚úÖ Token alone sufficient |
| **Token Length** | ‚úÖ 6 chars sufficient | ‚ö†Ô∏è 8 chars recommended |
| **Migration Complexity** | ‚úÖ Simpler | ‚ö†Ô∏è More complex |

**Recommendation by System Type:**

| System Type | Recommended Model | Rationale |
|-------------|-------------------|-----------|
| **Small-Medium SaaS** | Per-Entity-Type | Simpler implementation, adequate namespace |
| **Large Enterprise** | Global Uniqueness | Better UX, easier support, scales better |
| **Distributed/Microservices** | Global Uniqueness | Simpler routing, less coordination |
| **Monolithic Application** | Per-Entity-Type | Simpler constraints, faster lookups |
| **Customer-Facing Platform** | Global Uniqueness | Better UX, less confusion |
| **Internal Tools** | Per-Entity-Type | Adequate for internal use |

### 2.4 Validation Regex

```
^[A-Z]{3}-[A-HJ-NP-Z2-9]{6,8}-[A-HJ-NP-Z2-9]$
```

UTF-8 handling note: validators MUST reject any characters outside the allowed ASCII set; do
not attempt transliteration of Unicode lookalikes.

Test vectors (Normative): Implementations MUST include automated tests covering known-
good and known-bad CC-PID examples. At minimum, include the following cases (expected
results shown):

Known-good (format-valid; checksum must validate if generated by the official algorithm):

- PRJ-X2M8KD-F  -> VALID (if checksum matches)
- CLT-9F4K7Q-F  -> VALID (if checksum matches)
- INV-4Q7T9P-N  -> VALID (if checksum matches)
- TKT-2R7W9D-U  -> VALID (if checksum matches)
- USR-8H3K6P-D  -> VALID (if checksum matches)

Known-bad (must FAIL with the indicated error code):

- prj-x2m8kd-f        -> VALID after normalize (uppercase); DO NOT fail solely for casing
- PRJ- X2M8KD-F       -> INVALID_TOKEN_FORMAT (internal whitespace)
- PRJ-X2M8K-F         -> INVALID_TOKEN_FORMAT (token too short)
- PRJ-X2M8KDI-F       -> INVALID_TOKEN_FORMAT (contains I; disallowed)
- PRJ-X2M8KDO-F       -> INVALID_TOKEN_FORMAT (contains O; disallowed)
- PRJ-X2M8KD-0        -> INVALID_TOKEN_FORMAT (check digit contains 0; disallowed)
- PRJ-X2M8KD-1        -> INVALID_TOKEN_FORMAT (check digit contains 1; disallowed)
- PRJ-X2M8KD-X        -> CHECKSUM_MISMATCH (if X is not the computed CHK)
- PRJ-X2M8KD-F\n      -> VALID after trim; DO NOT allow internal whitespace
- PRJ-X2M8KD-F-EXTRA  -> INVALID_TOKEN_FORMAT (extra segment)

Note: For ‚ÄúKnown-good‚Äù vectors, compute the correct CHK using the official algorithm and
lock the final strings as deterministic fixtures within the test suite.

Copy/paste rule: Public Entity IDs MUST NOT contain leading or trailing whitespace. All
validators MUST `trim()` input before validation and MUST reject IDs that contain internal
whitespace characters.

### 2.5 Governance and Security Rules

1. Entity code registry ¬†‚Äì¬†every entity type (client, project, invoice, etc.) must be assigned a
   unique 3‚Äëletter code.  Codes are never reused, even if an entity type is deprecated. ID
   generation MUST retry on collision until a unique (entity_code, token) pair is persisted.
2. Immutability ¬†‚Äì¬†once generated, a public ID never changes.  Do not embed mutable
   metadata like version, date or environment.
3. Generation authority ¬†‚Äì¬†public IDs are generated server‚Äëside only using cryptographically
   secure randomness.  Clients must never supply or choose their own IDs.
4. Versioning ¬†‚Äì¬†this specification is version 1.1 (CC-PID v1).  If the format changes in the
   future, new versions must co‚Äëexist with v1; old IDs remain valid indefinitely.
5. **Business logic separation** ‚Äì Applications must not infer business logic, permissions, workflows, or UI behavior solely from the public ID or entity code. Entity codes exist for routing and classification only.
   
   **Guidance:** Entity codes MAY be used for service routing and storage partitioning (e.g., dispatch to the owning service or table family), but MUST NOT be used as an authorization signal.

6. **Deprecated entity types** ‚Äì Retain their codes indefinitely. No new records are created, but existing IDs remain valid for historical references, exports, and audits. No reuse under any circumstances.

   **6.1 Deprecation protocol (Guidance):** When an entity instance is retired or soft-deleted, its CC-PID remains reserved and MUST NOT be reused. Public-facing APIs SHOULD return HTTP 410 Gone for requests referencing a permanently retired entity (as opposed to 404 Not Found), and MAY include a non-sensitive error payload indicating the resource was retired.

7. **Collision Handling (Mandatory):** Generation MUST retry on collision. Minimum retries: up to 10 attempts. Collisions MUST be logged with entity code and timestamp. Repeated collisions MUST trigger alerting (possible RNG or constraint failure). If all retry attempts fail, the system MUST surface an operational error and MUST emit a high-severity alert. Collision rates above a minimal baseline SHOULD be treated as an indicator of RNG misuse, mis-scoped uniqueness constraints, or an implementation defect.

8. **Capability separation** ‚Äì Public Entity IDs MUST NOT be treated as capabilities or access tokens. Possession of an ID alone MUST NEVER grant access to data or actions.

9. **Entropy Source (Mandatory):** Token generation MUST use a CSPRNG. Non-cryptographic randomness (e.g., Math.random()) is forbidden.

10. **Timing-Safe Comparison (Guidance):** Public Entity IDs are non-secret labels; constant-time string comparison is REQUIRED for secrets (passwords, auth tokens, API key secrets) but OPTIONAL for Public Entity ID validation. Do not rely on timing behavior as a security boundary.

11. **Logging Guidance (Normative):** CC-PIDs are safe to log because they contain no PII and no semantic meaning. However, logs MUST NOT include CC-PIDs alongside user-identifying context (email, phone, name, IP address, session identifiers) in a way that creates a durable PII linkage. When correlation is required, use internal request IDs or hashed/rotating correlation identifiers.

12. **Rate Limiting (Guidance):** ID generation endpoints SHOULD enforce rate limits to prevent enumeration attacks and resource exhaustion. Recommended defaults: 100 IDs/second per entity type under normal operation; burst allowance of 500 IDs in a 10-second window for batch imports. Sustained generation exceeding 50 IDs/second SHOULD trigger monitoring alerts. Rate limiting is a defense-in-depth measure and does not replace proper authentication and authorization controls.

---

## 3. Implementation Guidelines

Although this document defines the patterns and rules, implementers may benefit from
reference code and database schemas.  The following guidelines reflect best practices:

Performance SLAs (Guidance): Reference implementations SHOULD meet the following per-
call targets on typical server hardware:

- generate: < 1 ms
- validate: < 0.1 ms
- parse: < 0.1 ms

These are guidance targets intended to keep CC-PID handling negligible in request latency.

Distributed Generation (Guidance): For horizontally-scaled deployments generating CC-PIDs

across multiple service instances, entity codes MAY be used as a routing key for partitioned

uniqueness enforcement. Recommended approaches: (1) Each instance generates tokens

independently and relies on database-level unique constraint with retry on collision; (2)

Centralized ID service with entity-code-based sharding; (3) Coordination-free generation

using 8-character tokens (lower collision probability ~1 in 1.1T). Implementations MUST NOT

embed instance identifiers or timestamps in tokens‚Äîtokens remain purely random.

### 3.1. UUIDs vs Public Entity IDs

| Aspect | UUID | CC-PID |
|--------|------|--------|
| **Visibility** | Internal only | External |
| **Mutability** | Immutable | Immutable |
| **Human-readable** | No | Yes |
| **Security** | Opaque | Non-secret |

**Rules:**

‚Ä¢ UUIDs MUST NEVER be exposed externally.

‚Ä¢ CC-PIDs MUST NEVER be used for authentication, authorization, or permission checks.

‚Ä¢ Public Entity IDs MUST NOT be treated as capabilities or access tokens.

### 3.2 Entity Code Registry

Entity codes are governed via a central registry: `entity-codes.json`

‚ö†Ô∏è **Governance:** Adding or modifying entity codes requires explicit review and approval by platform governance. Deprecated codes are retained indefinitely. Codes are never reused.

**Registry Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `code` | String | 3-letter entity code |
| `name` | String | Human-readable name |
| `description` | String | Purpose and usage |
| `owner` | String | Team/service owner |
| `status` | Enum | `ACTIVE` or `DEPRECATED` |
| `created_at` | Timestamp | Creation date |

---

### 3.3 Service Contract (Required)

All services handling CC-PID MUST implement:

**Core Methods:**
- `generate(entityCode, length)` - Generate new CC-PID
- `validate(publicId)` - Validate format and checksum
- `parse(publicId)` - Parse and extract components

‚ö†Ô∏è **Critical:** Checksum validation is REQUIRED at all input boundaries.

#### Standard Error Codes (Normative)

All services and SDKs handling CC-PIDs MUST use the following stable error identifiers:

| Error Code | Description |
|------------|-------------|
| `INVALID_ENTITY_CODE` | Entity segment invalid |
| `INVALID_TOKEN_FORMAT` | Token/CHK invalid chars/length/whitespace/segment count |
| `CHECKSUM_MISMATCH` | Checksum does not match computed CHK |
| `ID_NOT_FOUND` | Syntactically valid CC-PID that fails to resolve to a record |

**Notes:**
- ‚úÖ Use these codes in API responses, logs, and client SDKs for consistent handling
- ‚úÖ Human-readable messages MAY vary, but the code identifiers MUST remain stable

#### SDK Contract (Normative, language-agnostic)

In addition to generate/validate/parse, implementations SHOULD expose a minimal cross-language interface:

| Method | Signature | Description |
|--------|-----------|-------------|
| `normalize` | `(input: string) -> string` | Returns canonical uppercase CC-PID after trimming; rejects internal whitespace |
| `validateDetailed` | `(input: string) -> { ok: boolean, code?: string, normalized?: string, parts?: { entity, token, chk, publicId } }` | If ok=true, returns normalized CC-PID and parsed parts. If ok=false, code MUST be one of: `INVALID_ENTITY_CODE`, `INVALID_TOKEN_FORMAT`, `CHECKSUM_MISMATCH` |
| `format` | `(entity: string, token: string) -> string` | Returns canonical CC-PID string (ENTITY-TOKEN-CHK). Must compute CHK deterministically |
| `prefixQuery` | `(entity: string, tokenPrefix: string) -> string` | Returns canonical prefix pattern for UI lookup (ENTITY-TOKENPREFIX). Requires >=3 token chars; prefix match only |

**Important Notes:**
- Storage lookups (`ID_NOT_FOUND`) are not validation errors
- Services MAY return `ID_NOT_FOUND` only when a syntactically valid CC-PID fails to resolve to an entity

**Normalization Requirements:**
Services MUST normalize candidate CC-PID input by:
1. Trimming leading/trailing whitespace
2. Converting to uppercase
3. Applying regex and checksum validation

---

### 3.4 ID Generation Service

Implement a `PublicIdService` (e.g., in TypeScript) with methods to:

**Required Methods:**

| Method | Purpose |
|--------|---------|
| **Generate** | Create a new ID given an entity code and optional token length (6 or 8 characters) |
| **Parse** | Validate an existing ID, verifying the check digit |
| **Check** | Determine whether a string is a valid public ID (boolean return) |
| **Compute** | Calculate the check digit deterministically (e.g., first byte of SHA-256 of `<ENTITY>\|<TOKEN>` modulo the alphabet length) |

#### Validation Behavior (Guidance)

`validateDetailed()` SHOULD distinguish failures using standard codes:

| Error Code | Trigger Condition |
|------------|-------------------|
| `INVALID_ENTITY_CODE` | Entity segment invalid |
| `INVALID_TOKEN_FORMAT` | Token/CHK invalid chars/length/whitespace/segment count |
| `CHECKSUM_MISMATCH` | Checksum does not match computed CHK |
| `ID_NOT_FOUND` | Syntactically valid CC-PID that fails to resolve to a record |

#### Batch Generation (Guidance)

For bulk imports or migrations, implementations MAY provide a batch generator that returns up to **1000 generated IDs** per request/call (e.g., `generateBatch(entityCode, count, length)`).

‚ö†Ô∏è **Requirements:** Batch generation MUST apply the same:
- CSPRNG requirements
- Checksum rules
- Collision retry behavior as single ID generation

**Security:** The service should use a cryptographically secure random number generator for token generation and must retry on database uniqueness conflicts.

> üìÑ **Reference Implementation:** See the accompanying `public-id-service.ts` file for a complete example.

#### 3.4.1 Reference Implementation: `public-id-service.ts`

```typescript
import crypto from "crypto";

export type EntityCode = string; // validated at runtime

export type PublicIdParts = {
  entity: string;
  token: string;
  chk: string;
  publicId: string;
};

export type PublicIdErrorCode =
  | "INVALID_ENTITY_CODE"
  | "INVALID_TOKEN_FORMAT"
  | "CHECKSUM_MISMATCH"
  | ‚ÄúID_NOT_FOUND";

export type PublicIdValidationResult =
  | { ok: true; normalized: string; parts: PublicIdParts }
  | { ok: false; code: PublicIdErrorCode };

/**

* Service for generating and validating CYBERCUBE public IDs (CC-PID v1).
* 
* A public ID has the form `<ENTITY>-<TOKEN>-<CHK>` where:
* - ENTITY: exactly 3 uppercase letters identifying the entity type (e.g. CLT, PRJ).
* - TOKEN: a 6- or 8-character string from a human-safe alphabet (no I, O, 0, 1).
* - CHK: a single character check digit derived from ENTITY and TOKEN to detect typos.
    */
    export class PublicIdService {
    // Human-safe Base32-ish alphabet: no I, O, 0, 1
    public static readonly ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    public static readonly TOKEN_LEN_DEFAULT = 6;
    public static readonly TOKEN_LEN_HIGH_VOLUME = 8;

  // Regex for mandatory check digit format: ENTITY-TOKEN-CHK
  public static readonly PUBLIC_ID_REGEX =
  /^([A-Z]{3})-([A-HJ-NP-Z2-9]{6,8})-([A-HJ-NP-Z2-9])$/;

  /**
* Generate a new Public Entity ID (checksum mandatory).
* @param entity 3-letter entity code (validated).
* @param tokenLength length of the random token (6 or 8 characters).
  */
  static generate(entity: EntityCode, tokenLength: 6 | 8 = 6): PublicIdParts {
  this.assertEntity(entity);
  this.assertTokenLength(tokenLength);

  const token = this.randomToken(tokenLength);
  const chk = this.checkDigit(entity, token);
  const publicId =`${entity}-${token}-${chk}`;

  return { entity, token, chk, publicId };
  }

  /**
* Parse and validate a public id; verifies checksum.
* @param publicId candidate ID
* @returns the parsed components if valid; throws otherwise

   */
  static parse(publicId: string): PublicIdParts {
  // Normalize: trim + uppercase (copy/paste + case-insensitive input)
  const normalized = publicId.trim().toUpperCase();

  // Reject internal whitespace (tabs/newlines/spaces inside the ID)
  if (/\s/.test(normalized)) {
    throw new Error("Invalid Public ID: whitespace is not allowed");
  }

  const m = normalized.match(this.PUBLIC_ID_REGEX);
  if (!m) throw new Error("Invalid Public ID format");

  const entity = m[1];
  const token = m[2];
  const chk = m[3];

  // Verify check digit
  const expected = this.checkDigit(entity, token);
  if (chk !== expected) throw new Error("Invalid Public ID checksum");

  return { entity, token, chk, publicId: `${entity}-${token}-${chk}` };
}

/**

* Normalize candidate CC-PID input (copy/paste + case-insensitive input).
* - trims leading/trailing whitespace
* - uppercases for canonical form
* - rejects internal whitespace
    */
    static normalize(input: string): string {
    const normalized = input.trim().toUpperCase();
    if (/\s/.test(normalized)) {
    throw new Error("Invalid Public ID: whitespace is not allowed");
    }
    return normalized;
    }

/**

* Prefix-search helper for UIs (Guidance):
* - requires at least 3 token chars after the entity code
* - prefix match only (no substring search)
* Examples:
* - "PRJ-X2M" matches "PRJ-X2M8KD-F"
* - "prj-x2m" is accepted and normalized
    */
    static prefixQuery(entity: EntityCode, tokenPrefix: string): string {
    this.assertEntity(entity);

  const prefix = tokenPrefix.trim().toUpperCase();
  if (/\s/.test(prefix)) throw new Error("Invalid token prefix: whitespace is not allowed");
  if (prefix.length < 3) throw new Error("Token prefix must be at least 3 characters");

  // validate prefix chars against allowed token alphabet
  if (!new RegExp(`^[A-HJ-NP-Z2-9]{${prefix.length}}$`).test(prefix)) {
  throw new Error("Invalid token prefix characters");
  }

  // Caller can use this pattern to build LIKE queries: `${entity}-${prefix}%`
  return `${entity}-${prefix}`;
  }

  /**
* Format a canonical CC-PID string from entity code and token.
* Computes CHK deterministically.
* @param entity 3-letter entity code (uppercase)
* @param token random token string (6 or 8 chars)
* @returns canonical CC-PID string (ENTITY-TOKEN-CHK)
  */
  static format(entity: EntityCode, token: string): string {
  this.assertEntity(entity);
  const chk = this.checkDigit(entity, token);
  return `${entity}-${token}-${chk}`;
  }

  /**
* True/false validation (no throws).
* @param publicId candidate ID
* @returns true if valid, false otherwise
  */
  static isValid(publicId: string): boolean {
  try {
  this.parse(publicId);
  return true;
  } catch {
  return false;
  }
  }

/**

* Detailed validation with standardized error codes.
* This is validation-only; ID_NOT_FOUND must be handled by the caller
* after a successful parse when querying storage.
  */

static validateDetailed(input: string): PublicIdValidationResult {
  let normalized: string;

  try {
    normalized = this.normalize(input);
  } catch {
    return { ok: false, code: "INVALID_TOKEN_FORMAT" };
  }

  const match = normalized.match(this.PUBLIC_ID_REGEX);
  if (!match) {
    return { ok: false, code: "INVALID_TOKEN_FORMAT" };
  }

  const entity = match[1];
  const token = match[2];
  const chk = match[3];

  // NOTE: This format check is redundant with PUBLIC_ID_REGEX (defensive).
  // For registry-level validation (checking if the entity code is registered),
  // callers should verify entity against the entity-codes registry after parsing.
  if (!/^[A-Z]{3}$/.test(entity)) {
    return { ok: false, code: "INVALID_ENTITY_CODE" };
  }

  if (!/^[A-HJ-NP-Z2-9]{6,8}$/.test(token)) {
    return { ok: false, code: "INVALID_TOKEN_FORMAT" };
  }

  const expectedChk = this.checkDigit(entity, token);
  if (chk !== expectedChk) {
    return { ok: false, code: "CHECKSUM_MISMATCH" };
  }

  return {
    ok: true,
    normalized,
    parts: {
      entity,
      token,
      chk,
      publicId: normalized,
    },
  };
}

/**

* Validate + resolve helper (Guidance).
* Caller supplies a resolver function (DB lookup).
  */
  static async validateAndResolve<T>(
  input: string,
  resolver: (entity: string, token: string) => Promise<T | null>
  ): Promise<{ ok: true; entity: T } | { ok: false; code: PublicIdErrorCode }> {
  const result = this.validateDetailed(input);
  if (!result.ok) return result;

  const { entity, token } = result.parts;
  const record = await resolver(entity, token);

  if (!record) {
  return { ok: false, code: "ID_NOT_FOUND" };
  }

  return { ok: true, entity: record };
  }

  /**
* Compute 1-char check digit using SHA-256 algorithm (CC-PID v1 mandatory).
* Not a security feature‚Äîdetects typos only.
* 
* Algorithm: CHK = alphabet[ SHA256(entity + "|" + token)[0] mod 32 ]
* 
* @param entity 3-letter entity code (uppercase)
* @param token random token string (6 or 8 chars)
* @returns single character check digit from ALPHABET
  */
  static checkDigit(entity: string, token: string): string {
  this.assertEntity(entity);

  // CC-PID v1 Mandatory Algorithm: SHA-256(entity|token) -> first byte -> mod 32
  const input = `${entity}|${token}`;
  const digest = crypto.createHash("sha256").update(input, "utf8").digest();
  const idx = digest[0] % this.ALPHABET.length; // mod 32
  return this.ALPHABET[idx];
  }

  /**
* Validate entity code. Throws if invalid.

   * @param entity candidate code
   */
  static assertEntity(entity: string): asserts entity is EntityCode {
    if (!/^[A-Z]{3}$/.test(entity)) {
      throw new Error("Entity code must be exactly 3 uppercase letters");
    }
  }

  /**

* Ensure token length is 6 or 8.
* @param n candidate length
  */
  private static assertTokenLength(n: number): asserts n is 6 | 8 {
  if (n !== 6 && n !== 8) throw new Error("Token length must be 6 or 8");
  }

  /**
* Generate a random token of given length using ALPHABET.
* @param length length of token
  */
  static randomToken(length: number): string {
  let out = "";
  for (let i = 0; i < length; i++) {
  const idx = crypto.randomInt(0, this.ALPHABET.length);
  out += this.ALPHABET[idx];
  }
  return out;
  }
  }
```

#### 3.4.2 Cross-Language Reference Implementations

To ensure interoperability, here are reference implementations of the check digit algorithm in common languages:

**Python:**
```python
import hashlib

ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"

def check_digit(entity: str, token: str) -> str:
    """Compute CC-PID v1 check digit using SHA-256."""
    input_str = f"{entity}|{token}"
    digest = hashlib.sha256(input_str.encode('utf-8')).digest()
    idx = digest[0] % len(ALPHABET)  # mod 32
    return ALPHABET[idx]

# Test
assert check_digit("PRJ", "X2M8KD") == "F"
assert check_digit("CLT", "9F4K7Q") == "F"
```

**Go:**
```go
package ccpid

import (
    "crypto/sha256"
)

const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"

func CheckDigit(entity, token string) string {
    input := entity + "|" + token
    hash := sha256.Sum256([]byte(input))
    idx := hash[0] % 32
    return string(alphabet[idx])
}

// Test: CheckDigit("PRJ", "X2M8KD") == "F"
```

**Java:**
```java
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class CCPIDCheckDigit {
    private static final String ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    
    public static String checkDigit(String entity, String token) 
            throws NoSuchAlgorithmException {
        String input = entity + "|" + token;
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
        int idx = (hash[0] & 0xFF) % 32;
        return String.valueOf(ALPHABET.charAt(idx));
    }
    
    // Test: checkDigit("PRJ", "X2M8KD").equals("F")
}
```

**Ruby:**
```ruby
require 'digest'

ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"

def check_digit(entity, token)
  input = "#{entity}|#{token}"
  digest = Digest::SHA256.digest(input)
  idx = digest.bytes[0] % 32
  ALPHABET[idx]
end

# Test
raise unless check_digit("PRJ", "X2M8KD") == "F"
raise unless check_digit("CLT", "9F4K7Q") == "F"
```

**PHP:**
```php
<?php
const ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";

function checkDigit(string $entity, string $token): string {
    $input = $entity . "|" . $token;
    $digest = hash('sha256', $input, true);
    $idx = ord($digest[0]) % 32;
    return ALPHABET[$idx];
}

// Test
assert(checkDigit("PRJ", "X2M8KD") === "F");
assert(checkDigit("CLT", "9F4K7Q") === "F");
```

**Rust:**
```rust
use sha2::{Sha256, Digest};

const ALPHABET: &[u8] = b"ABCDEFGHJKLMNPQRSTUVWXYZ23456789";

fn check_digit(entity: &str, token: &str) -> char {
    let input = format!("{}|{}", entity, token);
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    let result = hasher.finalize();
    let idx = (result[0] % 32) as usize;
    ALPHABET[idx] as char
}

// Test: assert_eq!(check_digit("PRJ", "X2M8KD"), 'F');
```

**C#:**
```csharp
using System;
using System.Security.Cryptography;
using System.Text;

public class CCPIDCheckDigit
{
    private const string ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    
    public static string CheckDigit(string entity, string token)
    {
        string input = $"{entity}|{token}";
        using (var sha256 = SHA256.Create())
        {
            byte[] hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(input));
            int idx = hash[0] % 32;
            return ALPHABET[idx].ToString();
        }
    }
    
    // Test: CheckDigit("PRJ", "X2M8KD") == "F"
}
```

---

### 3.5 Database Constraints

For each table storing public IDs, define columns similar to:

| Column Name | Data Type | Description |
|-------------|-----------|-------------|
| `entity_code` | `CHAR(3)` | The 3-letter entity code (e.g., CLT) |
| `public_token` | `VARCHAR(8)` | Random token (6 or 8 characters) |
| `public_id` | `VARCHAR(16)` | Full ID (`<ENTITY>-<TOKEN>-<CHK>`) |
| `other columns` | ‚Ä¶ | Entity-specific data |

**Constraints:**
- ‚úÖ Enforce a unique index on `(entity_code, public_token)`
- ‚úÖ Optionally add unique index on `public_id`
- ‚úÖ Add a check constraint matching the validation regex above

---

### 3.6 Sample Implementation

A full TypeScript implementation of the `PublicIdService` (with deterministic checksum logic and parse/validate methods) is provided alongside this document in `public-id-service.ts`. A sample PostgreSQL migration with recommended constraints is provided in `db_migration.sql`.

> ‚ÑπÔ∏è **Note:** These files are not part of the specification but serve as a reference for implementers.

#### Migration Path (Guidance)

When migrating from legacy identifiers (numeric IDs, GUIDs previously exposed, or third-party keys):

**Recommended Approach:**

1. **Introduce CC-PID alongside legacy field** and maintain a mapping
2. **Store mapping columns:** `legacy_source` and `legacy_id`
3. **Enforce uniqueness** on `(legacy_source, legacy_id)`

**During Migration:**

| Step | Action |
|------|--------|
| 1 | Accept CC-PID when present |
| 2 | Accept legacy IDs for a defined transition window |
| 3 | Respond with canonical CC-PID in all new outputs |

**Example Mapping:**
```
LEGACY:<old-id> ‚Üí PRJ-<newtoken>-<chk>
```

‚ö†Ô∏è **Critical:** Legacy IDs must never be re-emitted once clients are updated.

---

#### 3.6.1 Reference Implementation: `db_migration.sql`

Sample PostgreSQL migration for adding public ID columns, constraints, and prefix-search support.

**Purpose:** This example shows how to modify an existing `clients` table to support CYBERCUBE public IDs (CC-PID v1).

**CC-PID Format:** `<ENTITY>-<TOKEN>-<CHK>`  
**Example:** `CLT-9F4K7Q-F`

**Notes:**
- ‚úÖ Public IDs are stored/displayed in UPPERCASE
- ‚úÖ Input validation must trim whitespace and normalize to uppercase in the application layer
- ‚úÖ This migration enforces format, uniqueness, and supports fast prefix-search
- ‚ö†Ô∏è This example uses per-entity-type uniqueness (see ¬ß2.3 for global uniqueness option)

> üìù **Reusability:** Apply similar changes to other entity tables (projects, invoices, etc.), adjusting the default `entity_code` accordingly.

```sql
BEGIN;

-- 1) Add columns (idempotency guards optional; remove IF NOT EXISTS if you prefer strict
migrations)
ALTER TABLE clients
    -- 3-letter entity code; defaults to 'CLT' for clients
    ADD COLUMN IF NOT EXISTS entity_code CHAR(3) NOT NULL DEFAULT 'CLT',
    -- Random token (6 or 8 characters)
    ADD COLUMN IF NOT EXISTS public_token VARCHAR(8) NOT NULL,
    -- Full public ID (`<ENTITY>`-`<TOKEN>`-`<CHK>`)
    ADD COLUMN IF NOT EXISTS public_id VARCHAR(16) NOT NULL;

-- 2) Entity code must be exactly 3 uppercase letters
ALTER TABLE clients
    ADD CONSTRAINT IF NOT EXISTS clients_entity_code_format_chk
        CHECK (entity_code ~ '^[A-Z]{3}$');

-- 3) Token must be 6 or 8 chars from the human-safe alphabet (no I, O, 0, 1)
ALTER TABLE clients
    ADD CONSTRAINT IF NOT EXISTS clients_public_token_format_chk
        CHECK (public_token ~ '^[A-HJ-NP-Z2-9]{6,8}$');

-- 4) Public ID must match mandatory format with check digit
-- (Whitespace trimming and case normalization are enforced in the application layer.)
ALTER TABLE clients
    ADD CONSTRAINT IF NOT EXISTS clients_public_id_format_chk
        CHECK (public_id ~ '^[A-Z]{3}-[A-HJ-NP-Z2-9]{6,8}-[A-HJ-NP-Z2-9]$');

-- 5) Optional consistency check: public_id should begin with entity_code + '-'
-- Helps prevent mismatches if public_id is constructed incorrectly.
ALTER TABLE clients
    ADD CONSTRAINT IF NOT EXISTS clients_public_id_entity_prefix_chk
        CHECK (left(public_id, 4) = entity_code || '-');

-- 6) Ensure uniqueness per entity type (entity_code + token)
CREATE UNIQUE INDEX IF NOT EXISTS clients_public_entity_token_uq
    ON clients (entity_code, public_token);

-- 7) Ensure the concatenated public ID is unique
CREATE UNIQUE INDEX IF NOT EXISTS clients_public_id_uq
    ON clients (public_id);

-- 8) Prefix-search index (recommended) for fast UI partial searches:
-- Query pattern:
--   WHERE entity_code = 'CLT' AND public_token LIKE 'X2M%'
-----------------------------------------------------------

-- Note: varchar_pattern_ops is appropriate for VARCHAR columns.
CREATE INDEX IF NOT EXISTS clients_public_token_prefix_idx
    ON clients (entity_code, public_token varchar_pattern_ops);

-- 9) Optional: prefix-search on full public_id (if your UI searches "CLT-X2M")
-- Query pattern:
--   WHERE public_id LIKE 'CLT-X2M%'
CREATE INDEX IF NOT EXISTS clients_public_id_prefix_idx
    ON clients (public_id varchar_pattern_ops);

COMMIT;
```

> üìù **Reusability:** Repeat similar statements for other entity tables (projects, invoices, etc.), adjusting the default `entity_code` accordingly (e.g., 'PRJ', 'INV').

#### 3.6.2 Global Token Uniqueness Implementation (Optional)

For implementations choosing global token uniqueness (see ¬ß2.3.2), use this approach:

**Centralized Token Registry:**

```sql
-- Create global token registry table
CREATE TABLE public_id_tokens (
    token VARCHAR(8) PRIMARY KEY,  -- Globally unique
    entity_code CHAR(3) NOT NULL,
    entity_table VARCHAR(50) NOT NULL,
    entity_pk UUID NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    CONSTRAINT token_format_chk 
        CHECK (token ~ '^[A-HJ-NP-Z2-9]{6,8}$'),
    CONSTRAINT entity_code_format_chk 
        CHECK (entity_code ~ '^[A-Z]{3}$')
);

-- Index for reverse lookup (entity ‚Üí token)
CREATE UNIQUE INDEX idx_tokens_entity_pk 
    ON public_id_tokens(entity_code, entity_table, entity_pk);

-- Index for entity type queries
CREATE INDEX idx_tokens_entity_code 
    ON public_id_tokens(entity_code);
```

**Entity Table Schema (Simplified):**

```sql
-- Entity tables only store the token (not entity_code)
ALTER TABLE clients
    ADD COLUMN IF NOT EXISTS public_token VARCHAR(8) NOT NULL,
    ADD COLUMN IF NOT EXISTS public_id VARCHAR(16) NOT NULL;

-- Foreign key to token registry
ALTER TABLE clients
    ADD CONSTRAINT clients_token_fk 
        FOREIGN KEY (public_token) 
        REFERENCES public_id_tokens(token);

-- Unique constraint on public_id
CREATE UNIQUE INDEX clients_public_id_uq 
    ON clients(public_id);
```

**ID Generation with Global Uniqueness:**

```typescript
async function generateGloballyUniqueId(
  entityCode: string, 
  entityTable: string,
  entityPk: string,
  tokenLength: 6 | 8 = 8  // Recommend 8 for global uniqueness
): Promise<PublicIdParts> {
  const maxRetries = 10;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const token = PublicIdService.randomToken(tokenLength);
    
    try {
      // Insert into global registry (will fail on collision)
      await db.query(`
        INSERT INTO public_id_tokens (token, entity_code, entity_table, entity_pk)
        VALUES ($1, $2, $3, $4)
      `, [token, entityCode, entityTable, entityPk]);
      
      const chk = PublicIdService.checkDigit(entityCode, token);
      const publicId = `${entityCode}-${token}-${chk}`;
      
      return { entity: entityCode, token, chk, publicId };
      
    } catch (error) {
      if (error.code === '23505') { // Unique violation
        // Retry with new token
        continue;
      }
      throw error;
    }
  }
  
  throw new Error('Failed to generate unique token after max retries');
}
```

**Advantages of Global Uniqueness:**
- ‚úÖ Simpler user experience (no duplicate-looking tokens)
- ‚úÖ Can route by token alone (faster lookup)
- ‚úÖ Better for distributed systems
- ‚úÖ Easier debugging and support
- ‚úÖ Future-proof for cross-entity operations

**Trade-offs:**
- Requires centralized token registry or coordination
- Slightly higher collision probability (mitigated by 8-char tokens)
- More complex database schema

**Recommendation:** Use global uniqueness for new systems, especially if:
- Building a distributed architecture
- Expecting high entity volumes across multiple types
- Prioritizing user experience and simplicity
- Using 8-character tokens

---

## 4. Tables

### 4.1. Crosswalk Table (Parent ‚Üí Subtype ‚Üí Full Code)

| Parent | Parent Name | Subtype | Subtype Name | Full Code |
|--------|-------------|---------|--------------|-----------|
| WA | Web Apps | SS | SaaS | WA-SS |
| WA | Web Apps | PO | Portals | WA-PO |
| WA | Web Apps | EC | E-Commerce | WA-EC |
| WA | Web Apps | CM | Content Management | WA-CM |
| MA | Mobile Apps | IO | iOS native | MA-IO |
| MA | Mobile Apps | AD | Android native | MA-AD |
| MA | Mobile Apps | XP | Cross-Platform | MA-XP |
| MA | Mobile Apps | PW | PWA | MA-PW |
| DA | Desktop Apps | MC | macOS | DA-MC |
| DA | Desktop Apps | WN | Windows | DA-WN |
| DA | Desktop Apps | LX | Linux | DA-LX |
| DA | Desktop Apps | XP | Cross-Platform | DA-XP |
| CS | Custom Software | WF | Custom Workflow | CS-WF |
| CS | Custom Software | ER | ERP/CRM Systems | CS-ER |
| CS | Custom Software | IT | Internal Tools | CS-IT |
| CS | Custom Software | ST | Suites | CS-ST |
| AP | API & Backend | RS | REST API | AP-RS |
| AP | API & Backend | GQ | GraphQL | AP-GQ |
| AP | API & Backend | MS | Microservices | AP-MS |
| AP | API & Backend | RT | Real-Time API | AP-RT |
| AP | API & Backend | BE | Backend Services | AP-BE |
| A1 | AI & Machine Learning | AS | AI Assistants | A1-AS |
| A1 | AI & Machine Learning | PD | Predictive | A1-PD |
| A1 | AI & Machine Learning | RC | Recommender | A1-RC |
| A1 | AI & Machine Learning | NL | NLP/CV/RAG | A1-NL |
| DT | Data & Analytics | BI | Business Intelligence | DT-BI |
| DT | Data & Analytics | ET | ETL Pipelines | DT-ET |
| DT | Data & Analytics | DW | Data Warehouse | DT-DW |
| DT | Data & Analytics | RP | Reporting | DT-RP |
| DC | DevOps & Cloud | CD | CI/CD | DC-CD |
| DC | DevOps & Cloud | MG | Cloud Migration | DC-MG |
| DC | DevOps & Cloud | IA | IaC | DC-IA |
| DC | DevOps & Cloud | MN | Monitoring | DC-MN |
| SC | Security & Compliance | AU | Authentication/Identity | SC-AU |
| SC | Security & Compliance | KM | Encryption/KMS | SC-KM |
| SC | Security & Compliance | PT | Pen Testing | SC-PT |
| SC | Security & Compliance | CM | Compliance | SC-CM |
| I1 | Embedded/IoT | FW | Firmware | I1-FW |
| I1 | Embedded/IoT | SY | Sync | I1-SY |
| I1 | Embedded/IoT | SN | Sensors | I1-SN |
| I1 | Embedded/IoT | RT | RTOS | I1-RT |
| GM | Games & Interactive | 2D | 2D Games | GM-2D |
| GM | Games & Interactive | 3D | 3D Games | GM-3D |
| GM | Games & Interactive | SM | Simulation | GM-SM |
| GM | Games & Interactive | VR | VR/AR | GM-VR |
| BC | Blockchain/Web3 | SC | Smart Contracts | BC-SC |
| BC | Blockchain/Web3 | NF | NFT | BC-NF |
| BC | Blockchain/Web3 | WL | Wallet | BC-WL |
| BC | Blockchain/Web3 | DF | DeFi | BC-DF |
| RP | Automation/RPA | BT | Bots | RP-BT |
| RP | Automation/RPA | WF | RPA Workflow | RP-WF |
| RP | Automation/RPA | NC | No-code Automation | RP-NC |
| IN | System Integrations | ER | ERP/CRM Integration | IN-ER |
| IN | System Integrations | PM | Payment Integration | IN-PM |
| IN | System Integrations | BR | API Bridge | IN-BR |
| IN | System Integrations | LG | Legacy Integration | IN-LG |
| MN | Maintenance/Support | BG | Bug Fixing | MN-BG |
| MN | Maintenance/Support | UP | Updates | MN-UP |
| MN | Maintenance/Support | OP | Optimization | MN-OP |
| MN | Maintenance/Support | TN | Configuration | MN-TN |
| CM | Communication | CH | Chat/Messaging | CM-CH |
| CM | Communication | EM | Email Systems | CM-EM |
| CM | Communication | VC | Video Conferencing | CM-VC |
| CM | Communication | CL | Collaboration | CM-CL |
| QA | Testing/QA | AT | Automated Testing | QA-AT |
| QA | Testing/QA | PT | Performance Testing | QA-PT |
| QA | Testing/QA | MT | Manual Testing | QA-MT |
| QA | Testing/QA | MN | Monitoring | QA-MN |

**Governance Classification (cross-domain overlay):**

| Classification | Applies To | Artifact Naming | Example |
|----------------|------------|-----------------|---------|
| **One-off project** | Any PARENT-SUB | Standard: `<PARENT>-<SUB>_<Name>_v...` | `WA-SS_ClientPortal_v1.0.0_20260101_PRD.zip` |
| **Product / Platform** | Any PARENT-SUB | Standard: `<PARENT>-<SUB>_<Name>_v...` | `WA-SS_MyWebsite_v2.1.0_20260115_PRD.zip` |
| **Reusable Standard Module (RSM)** | Any PARENT-SUB | Standard: `<PARENT>-<SUB>_<Name>_v...` | `SC-AU_IdentityModule_v1.0.0_20260110_PRD.zip` |

> ‚ÑπÔ∏è **Note:** RSM, One-off, and Product/Platform are governance attributes ‚Äî not domain codes. They classify how a deliverable is funded, versioned, and reused. All three use the same PARENT-SUB domain codes from the table above. See ¬ß4.1.0 for full definitions.

---

#### 4.1.0 Top-level Project Classification (Governance)

All deliverables are classified first by **Top-level Project Classification** (governance), then by Domain (PARENT‚ÄìSUB) per ¬ß4.1.1. This governance layer distinguishes how work is funded, versioned, and reused.

| Classification                           | Purpose                                                                        | Key distinction                                                                                |
| ---------------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| **One-off project**                | Single delivery for a client or internal need.                                 | ‚ùå Not versioned for reuse; ‚ùå Not a product/platform; ‚úÖ Scoped to one engagement or release. |
| **Product / Platform**             | Customer-facing product or internal platform.                                  | ‚ùå Not a one-off project; ‚ùå Not a reusable module; ‚úÖ Own roadmap, lifecycle, and delivery.   |
| **Reusable Standard Module (RSM)** | Versioned, governed, standalone module reused across multiple future projects. | ‚ùå Not a one-off project; ‚ùå Not a product/platform; ‚úÖ A certified building block.            |

**Reusable Standard Module (RSM) ‚Äî Definition**

**Purpose:** A Reusable Standard Module is a versioned, governed, standalone module designed to be reused across multiple future projects. It is a *productized internal asset* that sits between projects and platforms.

**Key distinction:**
- ‚ùå Not a one-off project
- ‚ùå Not a product/platform
- ‚úÖ A certified building block

> ‚ÑπÔ∏è **Note:** RSMs use the same Domain (PARENT‚ÄìSUB) codes as other deliverables (e.g., WA-SS, SC-AU) for artifact naming; the RSM classification is a governance attribute applied to the module (versioning, certification, reuse policy), not a substitute for domain coding.

---

#### 4.1.1 Project Classification Criteria

##### 4.1.1.1 WA ‚Äî Web Applications

Web-based systems accessed through browsers, requiring frontend + backend architecture.

| Subtype | Requirements |
|---------|--------------|
| **WA-SS** (SaaS) | ‚Ä¢ Multi-user authentication<br>‚Ä¢ Subscription or tiered access<br>‚Ä¢ Cloud-hosted backend<br>‚Ä¢ Multi-tenant capable architecture<br>‚Ä¢ Continuous delivery of features |
| **WA-PO** (Portals) | ‚Ä¢ User-specific views and dashboards<br>‚Ä¢ Role-based content access<br>‚Ä¢ Aggregated data from multiple sources<br>‚Ä¢ Personalized user experience |
| **WA-EC** (E-Commerce) | ‚Ä¢ Product catalog management<br>‚Ä¢ Shopping cart and checkout workflow<br>‚Ä¢ Payment gateway integration<br>‚Ä¢ Order and inventory management |
| **WA-CM** (Content Management) | ‚Ä¢ Content creation and editing interface<br>‚Ä¢ Version control and publishing workflow<br>‚Ä¢ Media library management<br>‚Ä¢ Multi-channel content delivery |

##### 4.1.1.2 MA ‚Äî Mobile Applications

Apps built for mobile devices (iOS/Android), native or cross-platform.

| Subtype | Requirements |
|---------|--------------|
| **MA-IO** (iOS native) | ‚Ä¢ Native iOS SDK and frameworks<br>‚Ä¢ App Store distribution<br>‚Ä¢ iOS platform-specific features and UX patterns |
| **MA-AD** (Android native) | ‚Ä¢ Native Android SDK and frameworks<br>‚Ä¢ Google Play distribution<br>‚Ä¢ Android platform-specific features and UX patterns |
| **MA-XP** (Cross-Platform) | ‚Ä¢ Unified codebase for iOS and Android<br>‚Ä¢ Cross-platform framework (e.g., Flutter, React Native, Xamarin)<br>‚Ä¢ Platform-specific adaptations where needed |
| **MA-PW** (PWA) | ‚Ä¢ Installable web application<br>‚Ä¢ Offline functionality via service workers<br>‚Ä¢ Native-like user experience<br>‚Ä¢ Progressive enhancement strategy |

##### 4.1.1.3 DA ‚Äî Desktop Applications

Installable applications for macOS, Windows, or Linux.

| Subtype | Platform | Requirements |
|---------|----------|--------------|
| **DA-MC** | macOS | ‚Ä¢ Native macOS frameworks and APIs<br>‚Ä¢ Mac App Store or direct distribution<br>‚Ä¢ macOS-specific UX conventions and integrations |
| **DA-WN** | Windows | ‚Ä¢ Native Windows frameworks and APIs<br>‚Ä¢ Windows installer package (.exe/.msi)<br>‚Ä¢ Windows-specific UX conventions and integrations |
| **DA-LX** | Linux | ‚Ä¢ Linux-native packaging (deb, rpm, AppImage, Flatpak)<br>‚Ä¢ Desktop environment integration<br>‚Ä¢ Linux distribution compatibility |
| **DA-XP** | Cross-Platform | ‚Ä¢ Single codebase for multiple desktop platforms<br>‚Ä¢ Cross-platform framework (e.g., Electron, Tauri, Qt)<br>‚Ä¢ Platform-specific adaptations where needed |

##### 4.1.1.4 CS ‚Äî Custom Software

Bespoke internal tools or systems built specifically for a business workflow.

| Subtype | Requirements |
|---------|--------------|
| **CS-WF** (Custom Workflow) | ‚Ä¢ Business-specific process automation<br>‚Ä¢ Custom business rules and logic<br>‚Ä¢ Workflow state management<br>‚Ä¢ Integration with existing business systems |
| **CS-ER** (ERP/CRM Systems) | ‚Ä¢ Enterprise resource planning or customer relationship management<br>‚Ä¢ Multi-module business operations (finance, inventory, sales, etc.)<br>‚Ä¢ Centralized business data management |
| **CS-IT** (Internal Tools) | ‚Ä¢ Organization-specific functionality<br>‚Ä¢ Internal user base only<br>‚Ä¢ Specialized operational requirements |
| **CS-ST** (Software Suites) | ‚Ä¢ Multiple integrated applications or modules<br>‚Ä¢ Unified authentication and user management<br>‚Ä¢ Consistent UI/UX across modules<br>‚Ä¢ Shared data model |

##### 4.1.1.5 AP ‚Äî API & Backend Services

Backend systems exposing programmatic interfaces or providing server-side functionality.

| Subtype | Requirements |
|---------|--------------|
| **AP-RS** (REST API) | ‚Ä¢ RESTful endpoint architecture<br>‚Ä¢ Resource-based URL structure<br>‚Ä¢ Standard HTTP methods and status codes<br>‚Ä¢ Stateless request handling |
| **AP-GQ** (GraphQL) | ‚Ä¢ GraphQL schema definition<br>‚Ä¢ Query and mutation operations<br>‚Ä¢ Resolver implementation<br>‚Ä¢ Type-safe API contracts |
| **AP-MS** (Microservices) | ‚Ä¢ Independently deployable services<br>‚Ä¢ Service-to-service communication<br>‚Ä¢ Distributed architecture<br>‚Ä¢ Domain-driven service boundaries |
| **AP-RT** (Real-Time API) | ‚Ä¢ Persistent connection support (WebSockets, SSE, etc.)<br>‚Ä¢ Live data streaming<br>‚Ä¢ Push-based updates<br>‚Ä¢ Low-latency communication |
| **AP-BE** (Backend Services) | ‚Ä¢ Server-side business logic<br>‚Ä¢ Background processing<br>‚Ä¢ Scheduled jobs and workers<br>‚Ä¢ Non-API backend functionality |

##### 4.1.1.6 A1 ‚Äî AI & Machine Learning

Systems using ML models, RAG, NLP, vision, or inference.

| Subtype | Requirements |
|---------|--------------|
| **A1-AS** (AI Assistants) | ‚Ä¢ Conversational interface<br>‚Ä¢ LLM or NLP engine<br>‚Ä¢ Action execution or reasoning |
| **A1-PD** (Predictive) | ‚Ä¢ Forecasting models<br>‚Ä¢ Historical dataset training |
| **A1-RC** (Recommender) | ‚Ä¢ Personalized suggestions<br>‚Ä¢ Behavioral or content-based models |
| **A1-NL** (NLP/CV/RAG) | ‚Ä¢ Natural language, vision, or retrieval-augmented tasks<br>‚Ä¢ Embeddings or vector search |

##### 4.1.1.7 DT ‚Äî Data & Analytics

Data-heavy or analytics-centric systems.

| Subtype | Requirements |
|---------|--------------|
| **DT-BI** (Business Intelligence) | ‚Ä¢ Strategic analytics and insights<br>‚Ä¢ Multi-dimensional data analysis<br>‚Ä¢ Executive dashboards and KPI visualization<br>‚Ä¢ Historical trend analysis and forecasting |
| **DT-ET** (ETL Pipelines) | ‚Ä¢ Data extraction from multiple sources<br>‚Ä¢ Data transformation and cleansing logic<br>‚Ä¢ Data loading to target systems<br>‚Ä¢ Batch or streaming data processing |
| **DT-DW** (Data Warehouse) | ‚Ä¢ Centralized enterprise data repository<br>‚Ä¢ OLAP and analytical query optimization<br>‚Ä¢ Historical data storage and archival<br>‚Ä¢ Data mart and cube structures |
| **DT-RP** (Reporting) | ‚Ä¢ Operational report generation<br>‚Ä¢ Scheduled and on-demand reporting<br>‚Ä¢ Report distribution and delivery<br>‚Ä¢ Standard metric calculations |

##### 4.1.1.8 DC ‚Äî DevOps & Cloud

Infrastructure, automation, and cloud platform engineering.

| Subtype | Requirements |
|---------|--------------|
| **DC-CD** (CI/CD) | ‚Ä¢ Automated builds<br>‚Ä¢ Automated tests<br>‚Ä¢ Deployment pipelines |
| **DC-MG** (Cloud Migration) | ‚Ä¢ Movement of workloads<br>‚Ä¢ Replatforming or containerization |
| **DC-IA** (IaC) | ‚Ä¢ Terraform/Pulumi/CloudFormation<br>‚Ä¢ Version-controlled infrastructure |
| **DC-MN** (Monitoring) | ‚Ä¢ Logging + alerting<br>‚Ä¢ Observability tooling |

##### 4.1.1.9 SC ‚Äî Security & Compliance

Security-focused systems or enhancements.

| Subtype | Requirements |
|---------|--------------|
| **SC-AU** (Authentication/Identity) | ‚Ä¢ User identity management<br>‚Ä¢ SSO/OAuth2/JWT |
| **SC-KM** (Encryption/KMS) | ‚Ä¢ Key storage<br>‚Ä¢ Encryption strategy |
| **SC-PT** (Pen Testing) | ‚Ä¢ Vulnerability scanning<br>‚Ä¢ Threat reports |
| **SC-CM** (Compliance) | ‚Ä¢ Auditing<br>‚Ä¢ Regulatory alignment |

##### 4.1.1.10 I1 ‚Äî Embedded / IoT

Hardware-connected or low-level software.

| Subtype | Requirements |
|---------|--------------|
| **I1-FW** (Firmware) | ‚Ä¢ Hardware-level logic<br>‚Ä¢ Microcontroller code |
| **I1-SY** (Sync) | ‚Ä¢ Cloud-hardware data sync<br>‚Ä¢ Device provisioning |
| **I1-SN** (Sensors) | ‚Ä¢ Sensor data handling<br>‚Ä¢ Real-time readings |
| **I1-RT** (RTOS) | ‚Ä¢ Real-time operating constraints |

##### 4.1.1.11 GM ‚Äî Games & Interactive

Graphical or interactive entertainment systems.

| Subtype | Requirements |
|---------|--------------|
| **GM-2D** (2D Games) | ‚Ä¢ 2D rendering and graphics pipeline<br>‚Ä¢ Sprite-based or vector graphics<br>‚Ä¢ 2D physics and collision detection |
| **GM-3D** (3D Games) | ‚Ä¢ 3D rendering and graphics pipeline<br>‚Ä¢ 3D models, textures, lighting, and shaders<br>‚Ä¢ 3D physics and spatial audio |
| **GM-SM** (Simulation) | ‚Ä¢ Real-world or abstract system modeling<br>‚Ä¢ Simulation logic and state management<br>‚Ä¢ Configurable simulation parameters |
| **GM-VR** (VR/AR) | ‚Ä¢ Virtual or augmented reality device support<br>‚Ä¢ Immersive 3D environments<br>‚Ä¢ Motion tracking and spatial interaction |

##### 4.1.1.12 BC ‚Äî Blockchain/Web3

Distributed-ledger or decentralized systems.

| Subtype | Requirements |
|---------|--------------|
| **BC-SC** (Smart Contracts) | ‚Ä¢ On-chain executable logic<br>‚Ä¢ Smart contract development and deployment<br>‚Ä¢ Contract interaction interfaces |
| **BC-NF** (NFT) | ‚Ä¢ Non-fungible token minting and management<br>‚Ä¢ Token metadata storage and retrieval<br>‚Ä¢ Marketplace or trading functionality |
| **BC-WL** (Wallet) | ‚Ä¢ Cryptographic key management<br>‚Ä¢ Transaction signing and broadcasting<br>‚Ä¢ Multi-chain or multi-asset support |
| **BC-DF** (DeFi) | ‚Ä¢ Decentralized finance protocols<br>‚Ä¢ Liquidity pools or yield mechanisms<br>‚Ä¢ On-chain financial operations |

##### 4.1.1.13 RP ‚Äî Automation / RPA

Automated workflows or software robots.

| Subtype | Requirements |
|---------|--------------|
| **RP-BT** (Bots) | ‚Ä¢ Automated agent execution<br>‚Ä¢ Task automation logic<br>‚Ä¢ Scripted or AI-driven control |
| **RP-WF** (RPA Workflow) | ‚Ä¢ Robotic process automation platform<br>‚Ä¢ Trigger-based action sequences<br>‚Ä¢ Multi-step flow orchestration<br>‚Ä¢ UI automation and screen scraping |
| **RP-NC** (No-code Automation) | ‚Ä¢ Visual workflow builder<br>‚Ä¢ Drag-and-drop logic composition<br>‚Ä¢ No-code or low-code interface<br>‚Ä¢ Pre-built automation templates |

##### 4.1.1.14 IN ‚Äî System Integrations

Bridging systems or connecting services.

| Subtype | Requirements |
|---------|--------------|
| **IN-ER** (ERP/CRM Integration) | ‚Ä¢ Enterprise system integration<br>‚Ä¢ Bidirectional data synchronization<br>‚Ä¢ Business process alignment |
| **IN-PM** (Payment Integration) | ‚Ä¢ Payment gateway integration<br>‚Ä¢ Secure transaction processing<br>‚Ä¢ Payment reconciliation<br>‚Ä¢ Multi-currency support |
| **IN-BR** (API Bridge) | ‚Ä¢ System-to-system middleware<br>‚Ä¢ Data format transformation<br>‚Ä¢ Protocol translation<br>‚Ä¢ Message routing and orchestration |
| **IN-LG** (Legacy Integration) | ‚Ä¢ Legacy system connectivity<br>‚Ä¢ Modernization bridge<br>‚Ä¢ Data migration support<br>‚Ä¢ Backward compatibility layer |

##### 4.1.1.15 MN ‚Äî Maintenance / Support

Ongoing maintenance and support activities for existing systems.

| Subtype | Requirements |
|---------|--------------|
| **MN-BG** (Bug Fixing) | ‚Ä¢ Defect identification and resolution<br>‚Ä¢ Patch releases and hotfixes<br>‚Ä¢ Regression testing<br>‚Ä¢ Root cause analysis |
| **MN-UP** (Updates) | ‚Ä¢ Feature enhancements and additions<br>‚Ä¢ Minor version releases<br>‚Ä¢ Dependency updates<br>‚Ä¢ Security patches |
| **MN-OP** (Optimization) | ‚Ä¢ Performance improvements<br>‚Ä¢ Resource utilization optimization<br>‚Ä¢ Code refactoring<br>‚Ä¢ Query and algorithm optimization |
| **MN-TN** (Configuration) | ‚Ä¢ System configuration adjustments<br>‚Ä¢ Parameter tuning<br>‚Ä¢ Environment-specific settings<br>‚Ä¢ Infrastructure optimization |

##### 4.1.1.16 CM ‚Äî Communication Systems

Messaging, collaboration, and communication platforms.

| Subtype | Requirements |
|---------|--------------|
| **CM-CH** (Chat/Messaging) | ‚Ä¢ Real-time messaging<br>‚Ä¢ User presence and status<br>‚Ä¢ Message history and search<br>‚Ä¢ Group conversations |
| **CM-EM** (Email Systems) | ‚Ä¢ Email composition and delivery<br>‚Ä¢ Inbox management<br>‚Ä¢ Email threading and organization<br>‚Ä¢ Attachment handling |
| **CM-VC** (Video Conferencing) | ‚Ä¢ Real-time video and audio streaming<br>‚Ä¢ Multi-participant support<br>‚Ä¢ Screen sharing<br>‚Ä¢ Recording capabilities |
| **CM-CL** (Collaboration) | ‚Ä¢ Real-time collaborative editing<br>‚Ä¢ Shared workspaces<br>‚Ä¢ Activity feeds and notifications<br>‚Ä¢ Team coordination tools |

##### 4.1.1.17 QA ‚Äî Testing & Quality Assurance

Testing frameworks, tools, and quality assurance systems.

| Subtype | Requirements |
|---------|--------------|
| **QA-AT** (Automated Testing) | ‚Ä¢ Test automation framework<br>‚Ä¢ Test case management<br>‚Ä¢ Continuous integration support<br>‚Ä¢ Test result reporting |
| **QA-PT** (Performance Testing) | ‚Ä¢ Load and stress testing<br>‚Ä¢ Performance metrics collection<br>‚Ä¢ Bottleneck identification<br>‚Ä¢ Scalability testing |
| **QA-MT** (Manual Testing) | ‚Ä¢ Test case documentation<br>‚Ä¢ Bug tracking and reporting<br>‚Ä¢ Test execution tracking<br>‚Ä¢ Defect lifecycle management |
| **QA-MN** (Monitoring) | ‚Ä¢ Application health monitoring<br>‚Ä¢ Error tracking and alerting<br>‚Ä¢ User experience monitoring<br>‚Ä¢ Service level monitoring |

---

### 4.2 Public Entity Codes (CC-PID v1)

Below are the 3-letter codes used in the CYBERCUBE Public Entity ID scheme.

| Code | Entity Name | Code | Entity Name |
|------|-------------|------|-------------|
| **CLT** | Client | **TSK** | Task |
| **ACC** | Organization / Account | **COM** | Comment |
| **USR** | User | **ATT** | Attachment |
| **CON** | Contact | **TAG** | Tag |
| **ADR** | Address | **SPR** | Sprint / Iteration |
| **TKT** | Support Ticket | **MLN** | Milestone |
| **NTF** | Notification | **BEN** | Benchmark |
| **PRJ** | Project | **PHZ** | Phase |
| **BRD** | Board | **INV** | Invoice |
| **COL** | Column | **PAY** | Payment |
| **CRD** | Card | **SUB** | Subscription |
| **PLN** | Plan | **API** | API Key record |
| **QTE** | Quote | **AUD** | Audit Event |
| **EST** | Estimate | **LOG** | Log Entry |
| **TXN** | Transaction | **JOB** | Background Job |
| **PRC** | Price / Rate | **WEB** | Webhook |
| **DSC** | Discount / Coupon | **INT** | Integration |
| **DOC** | Document | **ENV** | Environment |
| **PGS** | Page | **RLE** | Role |
| **FLE** | File | **PRM** | Permission |
| **FDR** | Folder | **POL** | Policy |
| **TMP** | Template | **SES** | Session |
| **FRM** | Form | **TOK** | Token (non-secret reference) |
| **SIG** | Signature Request | **DLV** | Deliverable |
| **MSG** | Message | **TEN** | Time Entry |
| **ACT** | Activity | **TMB** | Team Member |

#### 4.2.1 Entities Classification Reasoning

These 3-letter codes prefix all user-facing Public IDs. They identify the type of database entity. Each code should be used when generating or referencing an ID for that entity type.

**Customer & Organization:**
- **CLT** ‚Äî Client: identifies a client record in the customer management system
- **ACC** ‚Äî Organization/Account: represents an organizational tenant or account
- **USR** ‚Äî User: used for individual user accounts
- **CON** ‚Äî Contact: denotes a contact person tied to a client or organization
- **ADR** ‚Äî Address: represents a physical or mailing address entity

**Support & Communication:**
- **TKT** ‚Äî Support Ticket: used for customer support tickets
- **NTF** ‚Äî Notification: used for notification records (e.g., push or email notifications)
- **MSG** ‚Äî Message: used for direct messages or conversation records
- **COM** ‚Äî Comment: used for comments attached to tasks, cards, or tickets

**Project Management:**
- **PRJ** ‚Äî Project: identifies a project in the project management system
- **BRD** ‚Äî Board: denotes a board (e.g., Kanban or Scrum board)
- **COL** ‚Äî Column: represents a column within a board
- **CRD** ‚Äî Card: used for cards or tasks in a board
- **TSK** ‚Äî Task: identifies a task item
- **SPR** ‚Äî Sprint/Iteration: used for a sprint or iteration
- **MLN** ‚Äî Milestone: identifies milestones in project timelines
- **BEN** ‚Äî Benchmark: used for benchmark records or performance tests
- **PHZ** ‚Äî Phase: identifies a phase in a larger program or project
- **DLV** ‚Äî Deliverable: identifies a project deliverable or work product
- **ACT** ‚Äî Activity: used for activity log records or tracked actions
- **TMB** ‚Äî Team Member: identifies a team member assignment within a project or organization

**Billing & Finance:**
- **INV** ‚Äî Invoice: used for invoices in billing modules
- **PAY** ‚Äî Payment: used for payment transactions
- **SUB** ‚Äî Subscription: identifies subscription records (recurring billing)
- **PLN** ‚Äî Plan: denotes a pricing or service plan
- **QTE** ‚Äî Quote: used for formal quotes provided to clients
- **EST** ‚Äî Estimate: for cost or time estimates
- **TXN** ‚Äî Transaction: used for transactional records in finance modules
- **PRC** ‚Äî Price/Rate: represents pricing tiers or rates
- **DSC** ‚Äî Discount/Coupon: used for discount codes or coupons

**Content & Documents:**
- **DOC** ‚Äî Document: generic document entity
- **PGS** ‚Äî Page: denotes a page (e.g., wiki page, CMS page)
- **FLE** ‚Äî File: generic file stored in the system
- **FDR** ‚Äî Folder: used for folders or directories in file management modules
- **TMP** ‚Äî Template: identifies templates (e.g., email or document templates)
- **FRM** ‚Äî Form: used for forms in form builders or workflows
- **SIG** ‚Äî Signature Request: denotes a digital signature request
- **ATT** ‚Äî Attachment: identifies uploaded attachments or files
- **TAG** ‚Äî Tag: used for tags or labels applied to entities

**System & Integration:**
- **SES** ‚Äî Session: used for user sessions or login sessions
- **TOK** ‚Äî Token: records non-secret reference tokens (not auth tokens)
- **API** ‚Äî API Key Record: identifies an API key record (not the secret itself)
- **AUD** ‚Äî Audit Event: used for audit log events
- **LOG** ‚Äî Log Entry: denotes log entries or system logs
- **JOB** ‚Äî Background Job: identifies asynchronous jobs or tasks
- **WEB** ‚Äî Webhook: used for webhook records
- **INT** ‚Äî Integration: denotes integrations with external services
- **ENV** ‚Äî Environment: identifies environments (e.g., dev, staging, prod) in system config
- **TEN** ‚Äî Time Entry: used for time tracking records tied to tasks or projects

**Access Control:**
- **RLE** ‚Äî Role: used for role definitions in role-based access control
- **PRM** ‚Äî Permission: identifies permissions or entitlements
- **POL** ‚Äî Policy: denotes policies (e.g., access policies, security policies)

---

## 5. Ticket vs Issue (WOE) Separation

### 5.1 Customer Tickets (Entity)

Customer-facing support items are entities.

**Properties:**
- ‚úÖ Identifier: `TKT-*` (CC-PID)
- ‚úÖ Stored in database
- ‚úÖ Shown to customers
- ‚úÖ Used in URLs, emails, invoices, exports, and webhooks

### 5.2 Internal Issues / Work-Oriented Entries (WOE)

Engineering work items are artifacts.

**Properties:**
- ‚úÖ Identifier: WOE artifact key (e.g., `CS-ER-1427`)
- ‚úÖ Lives in Jira / GitHub / Linear
- ‚ùå Never exposed externally

### 5.3 Linking Rule (Mandatory)

If a customer ticket requires internal work:

**Rules:**
- ‚úÖ The Ticket entity stores one or more WOE references
- ‚úÖ Internal issues may reference the Ticket CC-PID

#### 5.3.1 Recommended Schema

```sql
external_key_source  -- JIRA | GITHUB | LINEAR | CYBERCUBE
external_key

-- Uniqueness constraint:
UNIQUE(external_key_source, external_key)
```

---

## 6. Version History

| Version | Date | Changes |
|---------|------|---------|
| v1.0 | 2025-12 | Initial release: artifact naming conventions, CC-PID format, entity code registry |
| v1.1 | 2026-01 | Added mandatory SHA-256 check digit algorithm, cross-language reference implementations (7 languages), SDK contract with standard error codes, batch generation guidance, global uniqueness model and decision matrix, collision handling requirements, rate limiting guidance, Support SOP |

---

## Developer Cheat Sheet

Below is a developer-first cheat sheet distilled from the final CYBERCUBE Naming & Identifier
Standard (v1.1).

This is meant to be printed, pinned, or dropped into a repo (/docs/ID_CHEATSHEET.md).

No theory. No prose. Just rules and examples.

### üîπ Two Namespaces (DO NOT MIX)

| Namespace A ‚Äî Artifacts | Namespace B ‚Äî Entities (CC-PID) |
|-------------------------|----------------------------------|
| **Used for:** Code & workflow, may change over time | **Used for:** Data & external references, NEVER changes |
| ‚Ä¢ Files<br>‚Ä¢ Repos<br>‚Ä¢ Branches<br>‚Ä¢ Commits<br>‚Ä¢ CI/CD outputs<br>‚Ä¢ Internal issues (WOE) | ‚Ä¢ Database entities<br>‚Ä¢ URLs<br>‚Ä¢ PDFs / exports<br>‚Ä¢ Emails<br>‚Ä¢ Webhooks |

### üîπ Namespace A ‚Äî Artifact Naming

**Canonical Pattern:**
```
<PARENT>-<SUB>_<ProjectName>_v<SemVer>_<YYYYMMDD>_<ENV>.<ext>
```

**Example:**
```
WA-SS_MyApp_v1.2.0_20250116_PRD.zip
```

**Artifact Rules:**
- ‚úÖ May include version, date, environment
- ‚úÖ May change over time
- ‚ùå NOT an identifier
- ‚ùå NOT stored as a primary key

### üîπ Internal Work Items (WOE)

**WOE = Work-Oriented Entry**

**Examples:**
- `CS-ER-1427`
- `AP-RS-0912`

**Rules:**
- ‚úÖ Internal only
- ‚úÖ Tracker-generated (Jira/GitHub/Linear)
- ‚úÖ Used in branches & commits
- ‚ùå Never shown to customers
- ‚ùå Never used in URLs or APIs

---

### üîπ Namespace B ‚Äî Public Entity IDs (CC-PID)

**Canonical Format (MANDATORY):**
```
<ENTITY>-<TOKEN>-<CHK>
```

**Example:**
```
TKT-9F4K7Q-V
```

**What CC-PID is:**
- ‚úÖ Immutable
- ‚úÖ Human-readable
- ‚úÖ Safe to expose
- ‚ùå NOT a secret
- ‚ùå NOT auth
- ‚ùå NOT authorization

---

### üîπ Entity Codes (3 letters)

**Examples:**
- `ACC` ‚Äî Account / Tenant
- `USR` ‚Äî User
- `PRJ` ‚Äî Project
- `TKT` ‚Äî Customer Ticket
- `INV` ‚Äî Invoice

**Rules:**
- ‚úÖ Uppercase
- ‚úÖ Centrally registered
- ‚ùå NEVER reused
- ‚ùå NEVER encode logic

---

### üîπ Token Rules

**Alphabet (human-safe):**
```
ABCDEFGHJKLMNPQRSTUVWXYZ23456789
```

**Length:**
- Default: **6** characters
- High-volume entities: **8** characters
- Global uniqueness: **8** characters (recommended)

**Uniqueness (Choose One):**
- **Per-entity-type:** Token unique within entity type (e.g., `CLT-9F4K7Q-F` and `PRJ-9F4K7Q-4` can coexist)
- **Global:** Token unique across all entity types (recommended for better UX)

**Rules:**
- ‚úÖ Random (CSPRNG)
- ‚úÖ No meaning
- ‚úÖ Unique (per chosen model)
- ‚úÖ Cross-language compatible

---

### üîπ Check Digit (CHK)

**Purpose:**
- ‚úÖ Detect typos
- ‚úÖ Manual entry safety

**Mandatory Algorithm (CC-PID v1):**
```
CHK = alphabet[ SHA256(entity + "|" + token)[0] mod 32 ]
```

**Implementation:**
- Input: `entity + "|" + token` (UTF-8 encoded)
- Hash: SHA-256 digest
- Select: First byte [0]
- Map: Modulo 32, then lookup in alphabet

**Rules:**
- ‚úÖ Mandatory
- ‚úÖ Deterministic (SHA-256 only)
- ‚úÖ Cross-language compatible
- ‚úÖ Interoperable across all services
- ‚ùå Not cryptographic
- ‚ùå Not security

---

### üîπ Validation Regex (Copy-Safe)

```regex
^[A-Z]{3}-[A-HJ-NP-Z2-9]{6,8}-[A-HJ-NP-Z2-9]$
```

**Always validate at:**
- ‚úÖ API boundaries
- ‚úÖ UI input
- ‚úÖ Import/export pipelines

---

### üîπ URL Format (Guidance)

Canonical URL pattern when embedding CC-PIDs:

/{entity-plural}/{CC-PID}

Examples:

- /projects/PRJ-X2M8KD-F
- /clients/CLT-9F4K7Q-F

Notes:

- The path segment is a human-friendly resource name.
- The authoritative identifier is the CC-PID.

---

### üîπ Hierarchical URL References (Guidance)

CC-PIDs are flat identifiers and MUST remain flat in storage.

For routing and readability, URLs MAY express hierarchy by composing CC-PIDs:

Examples:

- /projects/PRJ-X2M8KD-F/tasks/TSK-9F4K7Q-2
- /PRJ-X2M8KD-F/TSK-9F4K7Q-2

Rules:

- Hierarchy is URL-only.
- Never store concatenated IDs (no parent/child embedding in CC-PID).
- Always parse and validate each CC-PID independently.

---

### üîπ Versioning (Future-Reserved)

CC-PID v1 does NOT embed a version marker in the ID.

Guidance:

- Validation logic MUST be version-aware in the future.
- CYBERCUBE reserves the right to introduce a future token version prefix

  (e.g., reserving the first token character) if a breaking format change is required.
- All v1 IDs remain valid indefinitely.

---

### üîπ Internationalization & Encoding

Rules:

- CC-PIDs are ASCII-only and locale-safe.
- Treat CC-PIDs as UTF-8 strings at system boundaries.
- Normalize using ASCII rules only (trim + uppercase).
- Reject Unicode homoglyphs or non-ASCII characters.

---

### üîπ Deprecation & Deletion Semantics

Rules:

- CC-PIDs are never reused.
- Soft-deleted or retired entities retain their CC-PID forever.

API behavior (recommended):

- Return HTTP 410 Gone for permanently retired entities.
- Do NOT return 404 when the ID is known but retired.

---

### üîπ Migration from Legacy IDs (Guidance)

When migrating legacy identifiers:

- Introduce CC-PID alongside legacy ID.
- Maintain a mapping: (legacy_source, legacy_id) ‚Üí CC-PID.
- Accept legacy IDs only during a defined transition window.
- Always emit CC-PID in new responses.

Example:

LEGACY:12345 ‚Üí PRJ-X2M8KD-F

---

### üîπ Analytics & Observability Safety

CC-PIDs:

- Contain no PII
- Have no semantic meaning
- Use only URL/CSV-safe characters

Safe to use in:

- Analytics pipelines
- Event streams
- Logs and metrics
- Data warehouses

Access control must still protect underlying data.

---

### üîπ Input Normalization (REQUIRED)

Copy/paste + case rules:

- IDs MUST NOT contain leading/trailing whitespace.
- Validators MUST trim() input before validation.
- IDs are stored/displayed in UPPERCASE.
- Input MAY be accepted case-insensitively, but validators MUST normalize to uppercase
  before regex + checksum validation.
- Reject IDs containing any internal whitespace characters (spaces, tabs, newlines).

---

### üîπ Partial ID Search (Guidance)

UI search-by-ID behavior:

- Prefix match ONLY (no substring search).
- Require minimum 3 characters after the entity code.

Example:

- Search ‚ÄúPRJ-X2M‚Äù matches ‚ÄúPRJ-X2M8KD-F‚Äù

Reason:

- Reduces accidental matches and enumeration-style probing.

---

### üîπ UUID vs CC-PID

| Use Case | Use |
|----------|-----|
| Internal DB PK | UUIDv7 |
| External reference | CC-PID |

**Rules:**
- ‚ùå Never expose UUIDs
- ‚ùå Never auth with CC-PID
- ‚ùå ID ‚â† capability

---

### üîπ Tickets vs Issues (IMPORTANT)

| Customer Tickets | Internal Issues (WOE) |
|------------------|------------------------|
| ‚Ä¢ Entity<br>‚Ä¢ CC-PID: TKT-*<br>‚Ä¢ Stored in DB<br>‚Ä¢ Shown to customers<br>‚Ä¢ Used in URLs, emails, invoices | ‚Ä¢ Artifact<br>‚Ä¢ Tracker key (CS-ER-1427)<br>‚Ä¢ Internal only<br>‚Ä¢ Never customer-visible |

---

### üîπ Linking Tickets ‚Üî Internal Work

Required when support triggers engineering work.

**Ticket entity stores:**
```sql
external_key_source  -- (JIRA | GITHUB | LINEAR | CYBERCUBE)
external_key         -- (CS-ER-1427)

-- Constraint:
UNIQUE(external_key_source, external_key)
```

**Rules:**
- ‚úÖ Ticket is canonical
- ‚úÖ WOE is a reference
- ‚ùå Never expose WOE externally

---

### üîπ What You MUST NOT Do

- ‚ùå Use CC-PID for authentication
- ‚ùå Use CC-PID for authorization
- ‚ùå Parse meaning from IDs
- ‚ùå Reuse entity codes
- ‚ùå Let clients generate IDs
- ‚ùå Expose UUIDs

---

### üîπ Required Service Contract

Every service handling CC-PID MUST implement:

**Methods:**
- `generate(entityCode, length)`
- `validate(publicId)`
- `parse(publicId)`

**Requirements:**
- ‚úÖ Validate format + checksum (SHA-256)
- ‚úÖ Retry on collision (up to 10 attempts)
- ‚úÖ Route by ENTITY code
- ‚úÖ Document uniqueness model (per-entity or global)

---

### üîπ Mental Model (memorize this)

| Type | Purpose | Mutability |
|------|---------|------------|
| **Artifact** | Workflow label | Mutable |
| **WOE** | Internal work | Tracker-owned |
| **CC-PID** | External label | Immutable |
| **UUID** | Internal key | Hidden |

---

### üîπ One-Line Rule (if you remember nothing else)

If it leaves the system, it uses a CC-PID.

If it drives work, it‚Äôs an artifact.

If it‚Äôs internal, it‚Äôs a UUID or WOE.

---

## Appendix A: Support SOP ‚Äî Reading and Collecting Public Entity IDs (CC-PID)

### A.1 What to request from the customer

- Ask for the full CC-PID exactly as shown (format: ENTITY-TOKEN-CHK).
- If they can copy/paste, prefer copy/paste over typing.
- If they only have a screenshot, ask them to zoom in and read it slowly.

### A.2 Confirm format verbally

- Confirm the 3-letter entity code first (e.g., "PRJ", "TKT", "INV").
- Then confirm the token in groups of 2‚Äì3 characters.
- Then confirm the final check digit (CHK) as the last character.

### A.3 Phonetic reading (letters)

Use NATO phonetics for letters:

A=Alpha, B=Bravo, C=Charlie, D=Delta, E=Echo, F=Foxtrot, G=Golf, H=Hotel,

I=India, J=Juliett, K=Kilo, L=Lima, M=Mike, N=November, O=Oscar, P=Papa,

Q=Quebec, R=Romeo, S=Sierra, T=Tango, U=Uniform, V=Victor, W=Whiskey,

X=X-ray, Y=Yankee, Z=Zulu.

Digits are spoken as numbers (‚Äútwo‚Äù through ‚Äúnine‚Äù).

Note: Token alphabet excludes I and O to reduce confusion.

### A.4 How to handle common confusion

- If the customer says ‚ÄúI‚Äù or ‚ÄúO‚Äù, ask them to re-check: those letters are not valid in CC-PID
  tokens.
- If they say ‚Äúone‚Äù or ‚Äúzero‚Äù, ask them to re-check: 1 and 0 are not valid in CC-PID tokens.
- If a customer reads a lowercase ID, accept it and normalize to uppercase internally.

### A.5 Verification checks (support-side)

- Confirm there are no spaces before/after the ID.
- If the system reports ‚Äúinvalid checksum,‚Äù ask the customer to re-read ONLY the last character
  (CHK) and then the last 2‚Äì3 token characters.

### A.6 If the customer cannot provide full ID

- Ask for entity code + first 3 token characters (prefix).
- Use prefix search only (example: ‚ÄúPRJ-X2M‚Ä¶‚Äù).
- Never accept substring fragments from the middle of the token.

### A.7 Security reminder (non-negotiable)

- CC-PIDs are public labels and are NOT proof of identity.
- Never authenticate or authorize based on possession of a CC-PID.
- Always verify the customer using standard authentication and account verification steps.

---

## Implementation Status

**Last Updated:** 2026-01-17

### Core Implementation

| Component             | Status   | File                                                      |
| --------------------- | -------- | --------------------------------------------------------- |
| PublicIdService       | COMPLETE | `api/shared/public-id-service.ts`                       |
| Entity Codes Registry | COMPLETE | `api/shared/entity-codes.ts`                            |
| Database Migration    | COMPLETE | `api/migrations/029_add_public_id_columns.sql`          |
| Unit Tests            | COMPLETE | `api/tests/shared/public-id-service.test.ts` (54 tests) |
| Backfill Script       | COMPLETE | `api/scripts/backfill-public-ids.ts`                    |
| Middleware Helper     | COMPLETE | `api/middleware/validators/public-id.validators.ts`     |
| Quick Reference       | COMPLETE | `docs/guides/CC_PID_QUICK_REFERENCE.md`                 |

### Entity Support

| Entity       | Code | Repository                   | Routes              | Status          |
| ------------ | ---- | ---------------------------- | ------------------- | --------------- |
| Project      | PRJ  | `ProjectRepository.ts`     | `projects.ts`     | COMPLETE        |
| Task         | TSK  | `TaskRepository.ts`        | `tasks.ts`        | COMPLETE        |
| Milestone    | MLN  | `MilestoneRepository.ts`   | `tasks.ts`        | COMPLETE        |
| Invoice      | INV  | `InvoiceRepository.ts`     | `billing.ts`      | COMPLETE        |
| Deliverable  | DLV  | `DeliverableRepository.ts` | `deliverables.ts` | COMPLETE        |
| User         | USR  | -                            | -                   | MIGRATION READY |
| Message      | MSG  | -                            | -                   | MIGRATION READY |
| Time Entry   | TEN  | -                            | -                   | MIGRATION READY |
| Audit Log    | AUD  | -                            | -                   | MIGRATION READY |
| Activity     | ACT  | -                            | -                   | MIGRATION READY |
| Session      | SES  | -                            | -                   | MIGRATION READY |
| Role         | RLE  | -                            | -                   | MIGRATION READY |
| Permission   | PRM  | -                            | -                   | MIGRATION READY |
| Notification | NTF  | -                            | -                   | MIGRATION READY |
| Team Member  | TMB  | -                            | -                   | MIGRATION READY |

### Deployment Steps

```bash
# 1. Run database migration
npm run migrate

# 2. Backfill existing records with CC-PIDs
npx tsx api/scripts/backfill-public-ids.ts
```

### API Compatibility

All endpoints accepting entity IDs now support both formats:

- Numeric IDs: `/api/v1/projects/123`
- CC-PIDs: `/api/v1/projects/PRJ-X2M8KD-F`

---

## Related Documents

| Document | Relationship |
|----------|--------------|
| API Design Standard | CC-PID usage in REST endpoints, URL patterns |
| Data Classification & Retention Standard | Classification levels for entity data referenced by CC-PIDs |
| Soft-Delete Lifecycle Standard | Deprecation and 410 Gone semantics for retired CC-PIDs |
| Webhooks & Integrations Standard | CC-PID format in webhook payloads and integration events |
| Testing & Quality Standard | Test vector validation, reference implementation testing |
